<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://www.jianso.tech/lab</id>
    <title>CodeLab</title>
    <updated>2021-03-11T15:34:43.521Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://www.jianso.tech/lab"/>
    <link rel="self" href="https://www.jianso.tech/lab/atom.xml"/>
    <subtitle>眼睫毛的CodeLab</subtitle>
    <logo>https://www.jianso.tech/lab/images/avatar.png</logo>
    <icon>https://www.jianso.tech/lab/favicon.ico</icon>
    <rights>All rights reserved 2021, CodeLab</rights>
    <entry>
        <title type="html"><![CDATA[Hello World]]></title>
        <id>https://www.jianso.tech/lab/post/hello-world/</id>
        <link href="https://www.jianso.tech/lab/post/hello-world/">
        </link>
        <updated>2021-02-08T13:59:17.000Z</updated>
        <summary type="html"><![CDATA[<p>眼睫毛的CodeLab诞生了！</p>
]]></summary>
        <content type="html"><![CDATA[<p>眼睫毛的CodeLab诞生了！</p>
<!-- more -->
<p>此前虽然也搞过博客，WordPress ， 也用hexo,hugo写过博客，</p>
<p>但都最终没能坚持下来，这次决定好好积累自己的技术沉淀了，争取能多输出点文章📒📚</p>
<p>让我们一起加油吧，少年！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[职责链模式的适用场景]]></title>
        <id>https://www.jianso.tech/lab/post/职责链模式的适用场景/</id>
        <link href="https://www.jianso.tech/lab/post/职责链模式的适用场景/">
        </link>
        <updated>2021-01-31T07:05:29.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h2 id="什么是职责链模式">什么是职责链模式</h2>
<p>职责链模式（Chain of Responsibility），使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</p>
<p><strong>UML图：</strong></p>
<figure data-type="image" tabindex="1"><img src="http://img.yanjiemao.top/webp" alt="img" loading="lazy"></figure>
<p><strong>代码实现：</strong></p>
<p>Handler类，定义一个处理请示的接口</p>
<pre><code class="language-csharp">abstract class Handler{
    protected Handler successor;
    public void setSuccessor(Handler successor) {
        this.successor = successor;
    }
    
    // 处理请求的抽象方法
    public abstract void HandlerRequest(int request);
}
</code></pre>
<p>ConcreteHandler类，具体处理者类，处理它所负责的请求，可访问它的后继者，如果可处理该请求，就处理之，否则就将该请求转发给它的后继者</p>
<pre><code class="language-java">/**
 * ConcreteHandler1，请求数在0和10之间则有权处理，否则转到下一位
 */
class ConcreteHandler1 extends Handler{

    @Override
    public void HandlerRequest(int request) {
        if (request &gt;= 0 &amp;&amp; request &lt; 10) {
            System.out.println(&quot;ConcreteHandler1处理请求&quot;+request);
        }else if(successor !=null){
            successor.HandlerRequest(request);
        }
        
    }
    
}

/**
 *  ConcreteHandler2，请求数在10和20之间则有权处理，否则转到下一位
 */
class ConcreteHandler2 extends Handler{

    @Override
    public void HandlerRequest(int request) {
        if (request &gt;= 10 &amp;&amp; request &lt; 20) {
            System.out.println(&quot;ConcreteHandler2处理请求&quot;+request);
        }else if(successor !=null){
            successor.HandlerRequest(request);
        }
        
    }
    
}

/**
 *  ConcreteHandler3，请求数在20和30之间则有权处理，否则转到下一位
 */
class ConcreteHandler3 extends Handler{

    @Override
    public void HandlerRequest(int request) {
        if (request &gt;= 20 &amp;&amp; request &lt; 30) {
            System.out.println(&quot;ConcreteHandler3处理请求&quot;+request);
        }else if(successor !=null){
            successor.HandlerRequest(request);
        }
        
    }
    
}
</code></pre>
<p>客户端代码</p>
<pre><code class="language-cpp">public class ChainOfResponsibilityPattern {
    
    public static void main(String[] args) {
        Handler h1 = new ConcreteHandler1();
        Handler h2 = new ConcreteHandler2();
        Handler h3 = new ConcreteHandler3();
        
        h1.setSuccessor(h2);
        h2.setSuccessor(h3);
        
        int[] requests = {2,5,14,22,18,3,27,20};
        for (int i = 0; i &lt; requests.length; i++) {
            h1.HandlerRequest(requests[i]);
        }
    }

}
</code></pre>
<p>运行结果</p>
<pre><code class="language-undefined">ConcreteHandler1处理请求2
ConcreteHandler1处理请求5
ConcreteHandler2处理请求14
ConcreteHandler3处理请求22
ConcreteHandler2处理请求18
ConcreteHandler1处理请求3
ConcreteHandler3处理请求27
ConcreteHandler3处理请求20
</code></pre>
<h2 id="示例">示例</h2>
<p>在公司无论办什么事情都要走流程，一级一级审批。如果我们想请假，两天以内部门经理就可以批准，如果超过两天，五天以内总监有权限批准，五天以上就需要总经理批准了。如果我们想加薪就只能总经理审批。用程序模拟这个过程。</p>
<p><strong>UML图：</strong></p>
<figure data-type="image" tabindex="2"><img src="http://img.yanjiemao.top/webp-20210131231653541" alt="img" loading="lazy"></figure>
<p>职责链模式示例UML图.png</p>
<p><strong>代码实现：</strong></p>
<p>申请</p>
<pre><code class="language-cpp">public class Request {
    // 申请类别
    private String requestType;
    // 申请内容
    private String requestContent;
    // 申请数量
    private int number;
    public String getRequestType() {
        return requestType;
    }
    public void setRequestType(String requestType) {
        this.requestType = requestType;
    }
    public String getRequestContent() {
        return requestContent;
    }
    public void setRequestContent(String requestContent) {
        this.requestContent = requestContent;
    }
    public int getNumber() {
        return number;
    }
    public void setNumber(int number) {
        this.number = number;
    }
    
}
</code></pre>
<p>管理者</p>
<pre><code class="language-csharp">public abstract class Manager {

    protected String name;
    //管理者的上级
    protected Manager superior;
    public Manager(String name){
        this.name = name;
    }
    
    public void setSuperior(Manager superior) {
        this.superior = superior;
    }
    
    public abstract void RequestApplicatios(Request request);
}
</code></pre>
<p>总经理类</p>
<pre><code class="language-java">public class CommonManager extends Manager{

    public CommonManager(String name) {
        super(name);
    }

    @Override
    public void RequestApplicatios(Request request) {
        // 经理的权限就是可准许下两天以内的假期
        if(request.getRequestType().equals(&quot;请假&quot;) &amp;&amp; request.getNumber()&lt;=2){
            System.out.println(name+&quot;:&quot;+request.getRequestContent()+&quot; 数量&quot;+request.getNumber()+&quot;被批准&quot;);
        }
        // 其余的申请都需转到上级
        else{
            if(superior!=null){
                superior.RequestApplicatios(request);
            }
        }
    }

}
</code></pre>
<p>总监类</p>
<pre><code class="language-java">public class Majordomo extends Manager{

    public Majordomo(String name) {
        super(name);
    }

    @Override
    public void RequestApplicatios(Request request) {
        // 经理的权限就是可准许下属一周以内的假期
        if(request.getRequestType().equals(&quot;请假&quot;) &amp;&amp; request.getNumber()&lt;=5){
            System.out.println(name+&quot;:&quot;+request.getRequestContent()+&quot; 数量&quot;+request.getNumber()+&quot;被批准&quot;);
        }
        // 其余的申请都需转到上级
        else{
            if(superior!=null){
                superior.RequestApplicatios(request);
            }
        }
    }

}
</code></pre>
<p>总经理类，可以处理全部任何事情</p>
<pre><code class="language-csharp">public class GeneralManager extends Manager{

    public GeneralManager(String name) {
        super(name);
    }

    @Override
    public void RequestApplicatios(Request request) {
        if(request.getRequestType().equals(&quot;请假&quot;)){
            System.out.println(name+&quot;:&quot;+request.getRequestContent()+&quot; 数量&quot;+request.getNumber()+&quot;被批准&quot;);
        }
        else if(request.getRequestType().equals(&quot;加薪&quot;) &amp;&amp; request.getNumber() &lt;= 500){
            System.out.println(name+&quot;:&quot;+request.getRequestContent()+&quot; 数量&quot;+request.getNumber()+&quot;被批准&quot;);
        }
        else if(request.getRequestType().equals(&quot;加薪&quot;) &amp;&amp; request.getNumber() &gt; 500){
            System.out.println(name+&quot;:&quot;+request.getRequestContent()+&quot; 数量&quot;+request.getNumber()+&quot;再说吧&quot;);
        }
    }

}
</code></pre>
<p>客户端代码</p>
<pre><code class="language-cpp">public class Main {
    
    public static void main(String[] args) {
        CommonManager jingli = new CommonManager(&quot;经理&quot;);
        Majordomo zongjian = new Majordomo(&quot;总监&quot;);
        GeneralManager zongjingli = new GeneralManager(&quot;总经理&quot;);
        jingli.setSuperior(zongjian);
        zongjian.setSuperior(zongjingli);
        
        Request request = new Request();
        request.setRequestType(&quot;请假&quot;);
        request.setRequestContent(&quot;小明请假&quot;);
        request.setNumber(1);
        jingli.RequestApplicatios(request);
        
        Request request2 = new Request();
        request2.setRequestType(&quot;请假&quot;);
        request2.setRequestContent(&quot;小明请假&quot;);
        request2.setNumber(4);
        jingli.RequestApplicatios(request2);
        
        Request request3 = new Request();
        request3.setRequestType(&quot;加薪&quot;);
        request3.setRequestContent(&quot;小明请求加薪&quot;);
        request3.setNumber(500);
        jingli.RequestApplicatios(request3);
        
        Request request4 = new Request();
        request4.setRequestType(&quot;加薪&quot;);
        request4.setRequestContent(&quot;小明请求加薪&quot;);
        request4.setNumber(1000);
        jingli.RequestApplicatios(request4);
    }

}
</code></pre>
<p>运行结果</p>
<pre><code class="language-undefined">经理:小明请假 数量1被批准
总监:小明请假 数量4被批准
总经理:小明请求加薪 数量500被批准
总经理:小明请求加薪 数量1000再说吧
</code></pre>
<h2 id="总结">总结</h2>
<p>责任链中一个处理者对象，其中只有两个行为，一是处理请求，二是将请求转送给下一个节点，不允许某个处理者对象在处理了请求后又将请求转送给上一个节点的情况。对于一条责任链来说，一个请求最终只有两种情况，一是被某个处理对象所处理，另一个是所有对象均未对其处理，前一种情况称该责任链为纯的责任链，对于后一种情况称为不纯的责任链，实际应用中，多为不纯的责任链。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[工厂模式的适用场景]]></title>
        <id>https://www.jianso.tech/lab/post/工厂模式的适用场景/</id>
        <link href="https://www.jianso.tech/lab/post/工厂模式的适用场景/">
        </link>
        <updated>2021-01-31T06:46:47.000Z</updated>
        <content type="html"><![CDATA[<h2 id="什么是工厂模式">什么是工厂模式</h2>
<p>工厂顾名思义就是创建产品，根据产品是具体产品还是具体工厂可分为简单工厂模式和工厂方法模式，根据工厂的抽象程度可分为工厂方法模式和抽象工厂模式。该模式用于封装和管理对象的创建，是一种创建型模式。本文从一个具体的例子逐步深入分析，来体会三种工厂模式的应用场景和利弊。</p>
<h2 id="简单工厂模式">简单工厂模式</h2>
<p>该模式对对象创建管理方式最为简单，因为其仅仅简单的对不同类对象的创建进行了一层薄薄的封装。该模式通过向工厂传递类型来指定要创建的对象，其UML类图如下：</p>
<figure data-type="image" tabindex="1"><img src="http://img.yanjiemao.top/1419489-20190628144601084-563759643.png" alt="img" loading="lazy"></figure>
<p>下面我们使用手机生产来讲解该模式：</p>
<p><strong>Phone类</strong>：手机标准规范类(AbstractProduct)</p>
<pre><code>public interface Phone {
    void make();
}
</code></pre>
<p><strong>MiPhone类</strong>：制造小米手机（Product1）</p>
<pre><code>public class MiPhone implements Phone {
    public MiPhone() {
        this.make();
    }
    @Override
    public void make() {
        // TODO Auto-generated method stub
        System.out.println(&quot;make xiaomi phone!&quot;);
    }
}
</code></pre>
<p><strong>IPhone类</strong>：制造苹果手机（Product2）</p>
<pre><code>public class IPhone implements Phone {
    public IPhone() {
        this.make();
    }
    @Override
    public void make() {
        // TODO Auto-generated method stub
        System.out.println(&quot;make iphone!&quot;);
    }
}
</code></pre>
<p><strong>PhoneFactory类</strong>：手机代工厂（Factory）</p>
<pre><code>public class PhoneFactory {
    public Phone makePhone(String phoneType) {
        if(phoneType.equalsIgnoreCase(&quot;MiPhone&quot;)){
            return new MiPhone();
        }
        else if(phoneType.equalsIgnoreCase(&quot;iPhone&quot;)) {
            return new IPhone();
        }
        return null;
    }
}
</code></pre>
<p><strong>演示：</strong></p>
<pre><code>public class Demo {
    public static void main(String[] arg) {
        PhoneFactory factory = new PhoneFactory();
        Phone miPhone = factory.makePhone(&quot;MiPhone&quot;);            // make xiaomi phone!
        IPhone iPhone = (IPhone)factory.makePhone(&quot;iPhone&quot;);    // make iphone!
    }
}
</code></pre>
<h2 id="工厂方法模式factory-method">工厂方法模式(Factory Method)</h2>
<p>和简单工厂模式中工厂负责生产所有产品相比，工厂方法模式将生成具体产品的任务分发给具体的产品工厂，其UML类图如下：</p>
<figure data-type="image" tabindex="2"><img src="http://img.yanjiemao.top/1419489-20190628154133368-906051111-20210131225339435.png" alt="img" loading="lazy"></figure>
<p>也就是定义一个抽象工厂，其定义了产品的生产接口，但不负责具体的产品，将生产任务交给不同的派生类工厂。这样不用通过指定类型来创建对象了。</p>
<p>接下来继续使用生产手机的例子来讲解该模式。</p>
<p>其中和产品相关的Phone类、MiPhone类和IPhone类的定义不变。</p>
<p><strong>AbstractFactory类</strong>：生产不同产品的工厂的抽象类</p>
<pre><code>public interface AbstractFactory {
    Phone makePhone();
}
</code></pre>
<p><strong>XiaoMiFactory类</strong>：生产小米手机的工厂（ConcreteFactory1）</p>
<pre><code>public class XiaoMiFactory implements AbstractFactory{
    @Override
    public Phone makePhone() {
        return new MiPhone();
    }
}
</code></pre>
<p><strong>AppleFactory类</strong>：生产苹果手机的工厂（ConcreteFactory2）</p>
<pre><code>public class AppleFactory implements AbstractFactory {
    @Override
    public Phone makePhone() {
        return new IPhone();
    }
}
</code></pre>
<p><strong>演示：</strong></p>
<pre><code>public class Demo {
    public static void main(String[] arg) {
        AbstractFactory miFactory = new XiaoMiFactory();
        AbstractFactory appleFactory = new AppleFactory();
        miFactory.makePhone();            // make xiaomi phone!
        appleFactory.makePhone();        // make iphone!
    }
}
</code></pre>
<h2 id="抽象工厂模式abstract-factory">抽象工厂模式(Abstract Factory)</h2>
<p>上面两种模式不管工厂怎么拆分抽象，都只是针对一类产品<strong>Phone</strong>（AbstractProduct），如果要生成另一种产品PC，应该怎么表示呢？</p>
<p>最简单的方式是把2中介绍的工厂方法模式完全复制一份，不过这次生产的是PC。但同时也就意味着我们要完全复制和修改Phone生产管理的所有代码，显然这是一个笨办法，并不利于扩展和维护。</p>
<p>抽象工厂模式通过在AbstarctFactory中增加创建产品的接口，并在具体子工厂中实现新加产品的创建，当然前提是子工厂支持生产该产品。否则继承的这个接口可以什么也不干。</p>
<p>其UML类图如下：</p>
<figure data-type="image" tabindex="3"><img src="http://img.yanjiemao.top/1419489-20190628170705865-1781414242-20210131225348749.png" alt="img" loading="lazy"></figure>
<p>从上面类图结构中可以清楚的看到如何在工厂方法模式中通过增加新产品接口来实现产品的增加的。</p>
<p>接下来我们继续通过小米和苹果产品生产的例子来解释该模式。</p>
<p>为了弄清楚上面的结构，我们使用具体的产品和工厂来表示上面的UML类图，能更加清晰的看出模式是如何演变的：</p>
<figure data-type="image" tabindex="4"><img src="http://img.yanjiemao.top/1419489-20190628164001258-637961514-20210131225353537.png" alt="img" loading="lazy"></figure>
<p><strong>PC类</strong>：定义PC产品的接口(AbstractPC)</p>
<pre><code>public interface PC {
    void make();
}
</code></pre>
<p><strong>MiPC类</strong>：定义小米电脑产品(MIPC)</p>
<pre><code>public class MiPC implements PC {
    public MiPC() {
        this.make();
    }
    @Override
    public void make() {
        // TODO Auto-generated method stub
        System.out.println(&quot;make xiaomi PC!&quot;);
    }
}
</code></pre>
<p><strong>MAC类</strong>：定义苹果电脑产品(MAC)</p>
<pre><code>public class MAC implements PC {
    public MAC() {
        this.make();
    }
    @Override
    public void make() {
        // TODO Auto-generated method stub
        System.out.println(&quot;make MAC!&quot;);
    }
}
</code></pre>
<p>下面需要修改工厂相关的类的定义：</p>
<p><strong>AbstractFactory类</strong>：增加PC产品制造接口</p>
<pre><code>public interface AbstractFactory {
    Phone makePhone();
    PC makePC();
}
</code></pre>
<p><strong>XiaoMiFactory类</strong>：增加小米PC的制造（ConcreteFactory1）</p>
<pre><code>public class XiaoMiFactory implements AbstractFactory{
    @Override
    public Phone makePhone() {
        return new MiPhone();
    }
    @Override
    public PC makePC() {
        return new MiPC();
    }
}
</code></pre>
<p><strong>AppleFactory类</strong>：增加苹果PC的制造（ConcreteFactory2）</p>
<pre><code>public class AppleFactory implements AbstractFactory {
    @Override
    public Phone makePhone() {
        return new IPhone();
    }
    @Override
    public PC makePC() {
        return new MAC();
    }
}
</code></pre>
<p><strong>演示：</strong></p>
<pre><code>public class Demo {
    public static void main(String[] arg) {
        AbstractFactory miFactory = new XiaoMiFactory();
        AbstractFactory appleFactory = new AppleFactory();
        miFactory.makePhone();            // make xiaomi phone!
        miFactory.makePC();                // make xiaomi PC!
        appleFactory.makePhone();        // make iphone!
        appleFactory.makePC();            // make MAC!
    }
}
</code></pre>
<h3 id="总结">总结：</h3>
<p>上面介绍的三种工厂模式有各自的应用场景，实际应用时能解决问题满足需求即可，可灵活变通，无所谓高级与低级。</p>
<p>此外无论哪种模式，它们都有一个共同的特点，最终得有一个具体的工厂来负责处理，工厂模式适用于处理，条件简单且确定的情况</p>
<p>当情况变得不确定且复杂就要考虑换用其他模式。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[从kubectkl创建一个pod的过程]]></title>
        <id>https://www.jianso.tech/lab/post/从kubectkl创建一个pod的过程/</id>
        <link href="https://www.jianso.tech/lab/post/从kubectkl创建一个pod的过程/">
        </link>
        <updated>2021-01-22T05:51:21.000Z</updated>
        <content type="html"><![CDATA[<h2 id="kubectl">kubectl</h2>
<p>通过kubectl 执行下面的命令</p>
<pre><code class="language-bash">kubectl run --image=nginx
</code></pre>
<h3 id="验证">验证</h3>
<p>首先，客户端会先验证下，确保没有简单的错误，发现简单的错误请求就会被拦截，不会发送到apiserver，这样也可以减少apiserver的压力。</p>
<p>在kubectl客户端的简单验证通过后，就会把请求进行HTTP封装然后发送到apiserver。</p>
<p>在封装http请求之前还会进行身份验证，用户的凭证保存在kubeconfig文件中，用户找到这个文件然后进行解析验证，在解析验证通过后，就会把解析得到的用户信息也一同封装在http请求中</p>
<h2 id="kube-apiserver">kube-apiserver</h2>
<h3 id="认证">认证</h3>
<p>当apiserver 收到客户端的请求后，首先会进行证书认证，如果认证失败，则请求失败并返回相应的错误信息；如果验证成功，则将请求中的 <code>Authorization</code> 请求头删除，并将用户信息其上下文中。这给后续的授权和准入控制器提供了访问之前建立的用户身份的能力。</p>
<h3 id="授权">授权</h3>
<p>在通过apiserver 的验证后，还需要进行进行授权才能进行后面的操作。</p>
<p>kube-apiserver 目前支持以下几种授权方法：</p>
<ul>
<li>webhook 它与集群外的 HTTP(S) 服务交互。</li>
<li>ABAC它执行静态文件中定义的策略。</li>
<li>RBAC 它使用 <code>rbac.authorization.k8s.io</code> API Group实现授权决策，允许管理员通过 Kubernetes API 动态配置策略。</li>
<li>Node: 它确保 kubelet 只能访问自己节点上的资源。</li>
</ul>
<h3 id="准入控制">准入控制</h3>
<p>在进行授权操作之后，还有层层的控制，不同于授权和认证只关心请求的用户和操作，准入控制还处理请求的内容，并且仅对创建、更新、删除或连接（如代理）等有效，而对读操作无效。</p>
<p>{{&lt; warning &gt;}}</p>
<p>准入控制器的工作方式与授权者和验证者的工作方式类似，但有一点区别：与验证链和授权链不同，如果某个准入控制器检查不通过，则整个链会中断，整个请求将立即被拒绝并且返回一个错误给终端用户。</p>
<p>{{&lt;/ warning &gt;}}</p>
<p>准入控制器设计的重点在于提高可扩展性，某个控制器都作为一个插件存储在 <code>plugin/pkg/admission</code> 目录中，并且与某一个接口相匹配，最后被编译到 kube-apiserver 二进制文件中。</p>
<p>Kubernetes 目前支持的准入控制器有：</p>
<p>{{&lt; expandable label=&quot;控制器列表&quot; level=&quot;2&quot; &gt;}}</p>
<ul>
<li>AlwaysPullImages：此准入控制器修改每个 Pod 的时候都强制重新拉取镜像。</li>
<li>DefaultStorageClass：此准入控制器观察创建<code>PersistentVolumeClaim</code>时不请求任何特定存储类的对象，并自动向其添加默认存储类。这样，用户就不需要关注特殊存储类而获得默认存储类。</li>
<li>DefaultTolerationSeconds：此准入控制器将Pod的容忍时间<code>notready:NoExecute</code>和<code>unreachable:NoExecute</code> 默认设置为5分钟。</li>
<li>DenyEscalatingExec：此准入控制器将拒绝<code>exec</code> 和附加命令到以允许访问宿主机的升级了权限运行的pod。</li>
<li>EventRateLimit (alpha)：此准入控制器缓解了 API Server 被事件请求淹没的问题，限制时间速率。</li>
<li>ExtendedResourceToleration：此插件有助于创建具有扩展资源的专用节点。</li>
<li>ImagePolicyWebhook：此准入控制器允许后端判断镜像拉取策略，例如配置镜像仓库的密钥。</li>
<li>Initializers (alpha)：Pod初始化的准入控制器，详情请参考<a href="https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/">动态准入控制</a>。</li>
<li>LimitPodHardAntiAffinityTopology：此准入控制器拒绝任何在 <code>requiredDuringSchedulingRequiredDuringExecution</code> 的 <code>AntiAffinity</code> 字段中定义除了<code>kubernetes.io/hostname</code> 之外的拓扑关键字的 pod 。</li>
<li>LimitRanger：此准入控制器将确保所有资源请求不会超过 namespace 的 <code>LimitRange</code>。</li>
<li>MutatingAdmissionWebhook （1.9版本中为beta）：该准入控制器调用与请求匹配的任何变更 webhook。匹配的 webhook是串行调用的；如果需要，每个人都可以修改对象。</li>
<li>NamespaceAutoProvision：此准入控制器检查命名空间资源上的所有传入请求，并检查引用的命名空间是否存在。如果不存在就创建一个命名空间。</li>
<li>NamespaceExists：此许可控制器检查除 <code>Namespace</code> 其自身之外的命名空间资源上的所有请求。如果请求引用的命名空间不存在，则拒绝该请求。</li>
<li>NamespaceLifecycle：此准入控制器强制执行正在终止的命令空间中不能创建新对象，并确保<code>Namespace</code>拒绝不存在的请求。此准入控制器还防止缺失三个系统保留的命名空间<code>default</code>、<code>kube-system</code>、<code>kube-public</code>。</li>
<li>NodeRestriction：该准入控制器限制了 kubelet 可以修改的<code>Node</code>和<code>Pod</code>对象。</li>
<li>OwnerReferencesPermissionEnforcement：此准入控制器保护对<code>metadata.ownerReferences</code>对象的访问，以便只有对该对象具有“删除”权限的用户才能对其进行更改。</li>
<li>PodNodeSelector：此准入控制器通过读取命名空间注释和全局配置来限制可在命名空间内使用的节点选择器。</li>
<li>PodPreset：此准入控制器注入一个pod，其中包含匹配的PodPreset中指定的字段，详细信息见<a href="https://jimmysong.io/kubernetes-handbook/concepts/pod-preset.html">Pod Preset</a>。</li>
<li>PodSecurityPolicy：此准入控制器用于创建和修改pod，并根据请求的安全上下文和可用的Pod安全策略确定是否应该允许它。</li>
<li>PodTolerationRestriction：此准入控制器首先验证容器的容忍度与其命名空间的容忍度之间是否存在冲突，并在存在冲突时拒绝该容器请求。</li>
<li>Priority：此控制器使用<code>priorityClassName</code>字段并填充优先级的整数值。如果未找到优先级，则拒绝Pod。</li>
<li>ResourceQuota：此准入控制器将观察传入请求并确保它不违反命名空间的<code>ResourceQuota</code>对象中列举的任何约束。</li>
<li>SecurityContextDeny：此准入控制器将拒绝任何试图设置某些升级的<a href="https://kubernetes.io/docs/user-guide/security-context">SecurityContext</a>字段的pod 。</li>
<li>ServiceAccount：此准入控制器实现<a href="https://kubernetes.io/docs/user-guide/service-accounts">serviceAccounts的</a>自动化。</li>
</ul>
<p>{{&lt; /expandable  &gt;}}</p>
<h2 id="etcd">etcd</h2>
<p>到现在为止，Kubernetes 已经对该客户端的调用请求进行了全面彻底地审查，并且已经验证通过，运行它进入下一个环节。下一步 kube-apiserver 将对 HTTP 请求进行反序列化，然后利用得到的结果构建运行时对象（有点像 kubectl 生成器的逆过程），并保存到 <code>etcd</code> 中。下面我们将这个过程分解一下。</p>
<p>当收到请求时，kube-apiserver 是如何知道它该怎么做的呢？事实上，在客户端发送调用请求之前就已经产生了一系列非常复杂的流程。我们就从 kube-apiserver 二进制文件首次运行开始分析吧：</p>
<ol>
<li>当运行 kube-apiserver 二进制文件时，它会<a href="https://github.com/kubernetes/kubernetes/blob/7650665059e65b4b22375d1e28da5306536a12fb/cmd/kube-apiserver/app/server.go#L119">创建一个允许 apiserver 聚合的服务链</a>。这是一种对 <code>Kubernetes API</code> 进行扩展的方式。</li>
<li>同时会创建一个 <code>generic apiserver</code> 作为默认的 apiserver。</li>
<li>然后利用<a href="https://github.com/kubernetes/apiserver/blob/7001bc4df8883d4a0ec84cd4b2117655a0009b6c/pkg/server/config.go#L149">生成的 OpenAPI 规范</a>来填充 apiserver 的配置。</li>
<li>然后 kube-apiserver 遍历数据结构中指定的所有 API 组，并将每一个 API 组作为通用的存储抽象保存到 etcd 中。当你访问或变更资源状态时，kube-apiserver 就会调用这些 API 组。</li>
<li>每个 API 组都会遍历它的所有组版本，并且将每个 HTTP 路由<a href="https://github.com/kubernetes/apiserver/blob/7001bc4df8883d4a0ec84cd4b2117655a0009b6c/pkg/endpoints/groupversion.go#L92">映射到 REST 路径中</a>。</li>
<li>当请求的 METHOD 是 <code>POST</code> 时，kube-apiserver 就会将请求转交给 <a href="https://github.com/kubernetes/apiserver/blob/7001bc4df8883d4a0ec84cd4b2117655a0009b6c/pkg/endpoints/handlers/create.go#L37">资源创建处理器</a>。</li>
</ol>
<p>现在 kube-apiserver 已经知道了所有的路由及其对应的 REST 路径，以便在请求匹配时知道调用哪些处理器和键值存储。多么机智的设计！现在假设客户端的 HTTP 请求已经被 kube-apiserver 收到了：</p>
<ol>
<li>如果处理链可以将请求与已经注册的路由进行匹配，就会将该请求交给注册到该路由的<a href="https://github.com/kubernetes/apiserver/blob/7001bc4df8883d4a0ec84cd4b2117655a0009b6c/pkg/server/handler.go#L143">专用处理器</a>来处理；如果没有任何一个路由可以匹配该请求，就会将请求转交给<a href="https://github.com/kubernetes/apiserver/blob/7001bc4df8883d4a0ec84cd4b2117655a0009b6c/pkg/server/mux/pathrecorder.go#L248">基于路径的处理器</a>（比如当调用 <code>/apis</code> 时）；如果没有任何一个基于路径的处理器注册到该路径，请求就会被转交给 <a href="https://github.com/kubernetes/apiserver/blob/7001bc4df8883d4a0ec84cd4b2117655a0009b6c/pkg/server/mux/pathrecorder.go#L254">not found 处理器</a>，最后返回 <code>404</code>。</li>
<li>幸运的是，我们有一个名为 <code>createHandler</code> 的注册路由！它有什么作用呢？首先它会解码 HTTP 请求并进行基本的验证，例如确保请求提供的 json 与 API 资源的版本相匹配。</li>
<li>接下来进入<a href="https://github.com/kubernetes/apiserver/blob/7001bc4df8883d4a0ec84cd4b2117655a0009b6c/pkg/endpoints/handlers/create.go#L93-L104">审计和准入控制</a>阶段。</li>
<li>然后资源将会通过 <a href="https://github.com/kubernetes/apiserver/blob/19667a1afc13cc13930c40a20f2c12bbdcaaa246/pkg/registry/generic/registry/store.go#L327">storage provider</a> 保存<a href="https://github.com/kubernetes/apiserver/blob/7001bc4df8883d4a0ec84cd4b2117655a0009b6c/pkg/endpoints/handlers/create.go#L111">到 etcd</a> 中。默认情况下保存到 etcd 中的键的格式为 <code>&lt;namespace&gt;/&lt;name&gt;</code>，你也可以自定义。</li>
<li>资源创建过程中出现的任何错误都会被捕获，最后 <code>storage provider</code> 会执行 <code>get</code> 调用来确认该资源是否被成功创建。如果需要额外的清理工作，就会调用后期创建的处理器和装饰器。</li>
<li>最后构造 HTTP 响应并返回给客户端。</li>
</ol>
<p>原来 apiserver 做了这么多的工作，以前竟然没有发现呢！到目前为止，我们创建的 <code>Deployment</code> 资源已经保存到了 etcd 中，但 apiserver 仍然看不到它。</p>
<h2 id="初始化">初始化</h2>
<hr>
<p>在一个资源对象被持久化到数据存储之后，apiserver 还无法完全看到或调度它，在此之前还要执行一系列<a href="https://v1-13.docs.kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#initializers">Initializers</a>。Initializers是一种与资源类型相关联的控制器，它会在资源对外可用之前执行某些逻辑。如果某个资源类型没有Initializers，就会跳过此初始化步骤立即使资源对外可见。</p>
<p>正如<a href="https://ahmet.im/blog/initializers/">大佬的博客</a>指出的那样，Initializers是一个强大的功能，因为它允许我们执行通用引导操作。例如：</p>
<ul>
<li>将代理边车容器注入到暴露 80 端口的 Pod 中，或者加上特定的 <code>annotation</code>。</li>
<li>将保存着测试证书的 <code>volume</code> 注入到特定命名空间的所有 Pod 中。</li>
<li>如果 <code>Secret</code> 中的密码小于 20 个字符，就组织其创建。</li>
</ul>
<p><code>initializerConfiguration</code> 资源对象允许你声明某些资源类型应该运行哪些Initializers。如果你想每创建一个 Pod 时就运行一个自定义Initializers，你可以这样做：</p>
<pre><code class="language-yaml">apiVersion: admissionregistration.k8s.io/v1alpha1
kind: InitializerConfiguration
metadata:
  name: custom-pod-initializer
initializers:
  - name: podimage.example.com
    rules:
      - apiGroups:
          - &quot;&quot;
        apiVersions:
          - v1
        resources:
          - pods
</code></pre>
<p>通过该配置创建资源对象 <code>InitializerConfiguration</code> 之后，就会在每个 Pod 的 <code>metadata.initializers.pending</code> 字段中添加 <code>custom-pod-initializer</code> 字段。该初始化控制器会定期扫描新的 Pod，一旦在 Pod 的 <code>pending</code> 字段中检测到自己的名称，就会执行其逻辑，执行完逻辑之后就会将 <code>pending</code> 字段下的自己的名称删除。</p>
<p>只有在 <code>pending</code> 字段下的列表中的第一个Initializers可以对资源进行操作，当所有的Initializers执行完成，并且 <code>pending</code> 字段为空时，该对象就会被认为初始化成功。</p>
<p><strong>你可能会注意到一个问题：如果 kube-apiserver 不能显示这些资源，那么用户级控制器是如何处理资源的呢？</strong></p>
<p>为了解决这个问题，kube-apiserver 暴露了一个 <code>?includeUninitialized</code> 查询参数，它会返回所有的资源对象（包括未初始化的）。</p>
<h2 id="控制循环">控制循环</h2>
<hr>
<h3 id="deployments-controller">Deployments controller</h3>
<p>到了这个阶段，我们的 Deployment 记录已经保存在 etcd 中，并且所有的初始化逻辑都执行完成，接下来的阶段将会涉及到该资源所依赖的拓扑结构。在 Kubernetes 中，Deployment 实际上只是一系列 <code>Replicaset</code> 的集合，而 Replicaset 是一系列 <code>Pod</code> 的集合。那么 Kubernetes 是如何从一个 HTTP 请求按照层级结构依次创建这些资源的呢？其实这些工作都是由 Kubernetes 内置的 <code>Controller</code>(控制器) 来完成的。</p>
<p>Kubernetes 在整个系统中使用了大量的 Controller，Controller 是一个用于将系统状态从“当前状态”修正到“期望状态”的异步脚本。所有 Controller 都通过 <code>kube-controller-manager</code> 组件并行运行，每种 Controller 都负责一种具体的控制流程。首先介绍一下 <code>Deployment Controller</code>：</p>
<p>将 Deployment 记录存储到 etcd 并初始化后，就可以通过 kube-apiserver 使其可见，然后 <code>Deployment Controller</code> 就会检测到它（它的工作就是负责监听 Deployment 记录的更改）。在我们的例子中，控制器通过一个 <code>Informer</code> <a href="https://github.com/kubernetes/kubernetes/blob/7650665059e65b4b22375d1e28da5306536a12fb/pkg/controller/deployment/deployment_controller.go#L122">注册一个创建事件的特定回调函数</a>（更多信息参加下文）。</p>
<p>当 Deployment 第一次对外可见时，该 Controller 就会<a href="https://github.com/kubernetes/kubernetes/blob/7650665059e65b4b22375d1e28da5306536a12fb/pkg/controller/deployment/deployment_controller.go#L170">将该资源对象添加到内部工作队列</a>，然后开始处理这个资源对象：</p>
<blockquote>
<p>通过使用标签选择器查询 kube-apiserver 来<a href="https://github.com/kubernetes/kubernetes/blob/7650665059e65b4b22375d1e28da5306536a12fb/pkg/controller/deployment/deployment_controller.go#L633">检查</a>该 Deployment 是否有与其关联的 <code>ReplicaSet</code> 或 <code>Pod</code> 记录。</p>
</blockquote>
<p>有趣的是，这个同步过程是状态不可知的，它核对新记录与核对已经存在的记录采用的是相同的方式。</p>
<p>在意识到没有与其关联的 <code>ReplicaSet</code> 或 <code>Pod</code> 记录后，Deployment Controller 就会开始执行<a href="https://github.com/kubernetes/kubernetes/blob/7650665059e65b4b22375d1e28da5306536a12fb/pkg/controller/deployment/sync.go#L385">弹性伸缩流程</a>：</p>
<blockquote>
<p>创建 ReplicaSet 资源，为其分配一个标签选择器并将其版本号设置为 1。</p>
</blockquote>
<p>ReplicaSet 的 <code>PodSpec</code> 字段从 Deployment 的 manifest 以及其他相关元数据中复制而来。有时 Deployment 记录在此之后也需要更新（例如，如果设置了 <code>process deadline</code>）。</p>
<p>当完成以上步骤之后，该 Deployment 的 <code>status</code> 就会被更新，然后重新进入与之前相同的循环，等待 Deployment 与期望的状态相匹配。由于 Deployment Controller 只关心 ReplicaSet，因此需要通过 <code>ReplicaSet Controller</code> 来继续协调。</p>
<h3 id="replicasets-controller">ReplicaSets controller</h3>
<p>在前面的步骤中，Deployment Controller 创建了第一个 ReplicaSet，但仍然还是没有 Pod，这时候就该 <code>ReplicaSet Controller</code> 登场了！ReplicaSet Controller 的工作是监视 ReplicaSets 及其相关资源（Pod）的生命周期。和大多数其他 Controller 一样，它通过触发某些事件的处理器来实现此目的。</p>
<p>当创建 ReplicaSet 时（由 Deployment Controller 创建），RS Controller <a href="https://github.com/kubernetes/kubernetes/blob/7650665059e65b4b22375d1e28da5306536a12fb/pkg/controller/replicaset/replica_set.go#L583">检查新 ReplicaSet 的状态</a>，并检查当前状态与期望状态之间存在的偏差，然后通过<a href="https://github.com/kubernetes/kubernetes/blob/7650665059e65b4b22375d1e28da5306536a12fb/pkg/controller/replicaset/replica_set.go#L460">调整 Pod 的副本数</a>来达到期望的状态。</p>
<p>Pod 的创建也是批量进行的，从 <code>SlowStartInitialBatchSize</code> 开始，然后在每次成功的迭代中以一种 <code>slow start</code> 操作加倍。这样做的目的是在大量 Pod 启动失败时（例如，由于资源配额），可以减轻 kube-apiserver 被大量不必要的 HTTP 请求吞没的风险。如果创建失败，最好能够优雅地失败，并且对其他的系统组件造成的影响最小！</p>
<p>Kubernetes 通过 <code>Owner References</code>（在子级资源的某个字段中引用其父级资源的 ID） 来构造严格的资源对象层级结构。这确保了一旦 Controller 管理的资源被删除（级联删除），子资源就会被垃圾收集器删除，同时还为父级资源提供了一种有效的方式来避免他们竞争同一个子级资源（想象两对父母都认为他们拥有同一个孩子的场景）。</p>
<p>Owner References 的另一个好处是：它是有状态的。如果有任何 Controller 重启了，那么由于资源对象的拓扑关系与 Controller 无关，该操作不会影响到系统的稳定运行。这种对资源隔离的重视也体现在 Controller 本身的设计中：Controller 不能对自己没有明确拥有的资源进行操作，它们应该选择对资源的所有权，互不干涉，互不共享。</p>
<p>有时系统中也会出现孤儿（orphaned）资源，通常由以下两种途径产生：</p>
<ul>
<li>父级资源被删除，但子级资源没有被删除</li>
<li>垃圾收集策略禁止删除子级资源</li>
</ul>
<p>当发生这种情况时，Controller 将会确保孤儿资源拥有新的 <code>Owner</code>。多个父级资源可以相互竞争同一个孤儿资源，但只有一个会成功（其他父级资源会收到验证错误）。</p>
<h3 id="informers">Informers</h3>
<p>你可能已经注意到，某些 Controller（例如 RBAC 授权器或 Deployment Controller）需要先检索集群状态然后才能正常运行。拿 RBAC 授权器举例，当请求进入时，授权器会将用户的初始状态缓存下来，然后用它来检索与 etcd 中的用户关联的所有 角色（<code>Role</code>）和 角色绑定（<code>RoleBinding</code>）。那么问题来了，Controller 是如何访问和修改这些资源对象的呢？事实上 Kubernetes 是通过 <code>Informer</code> 机制来解决这个问题的。</p>
<p>Infomer 是一种模式，它允许 Controller 查找缓存在本地内存中的数据(这份数据由 Informer 自己维护)并列出它们感兴趣的资源。</p>
<p>虽然 Informer 的设计很抽象，但它在内部实现了大量的对细节的处理逻辑（例如缓存），缓存很重要，因为它不但可以减少对 Kubenetes API 的直接调用，同时也能减少 Server 和 Controller 的大量重复性工作。通过使用 Informer，不同的 Controller 之间以线程安全（Thread safety）的方式进行交互，而不必担心多个线程访问相同的资源时会产生冲突。</p>
<p>有关 Informer 的更多详细解析，请参考这篇文章：<a href="https://borismattijssen.github.io/articles/kubernetes-informers-controllers-reflectors-stores">Kubernetes: Controllers, Informers, Reflectors and Stores</a></p>
<h3 id="scheduler">Scheduler</h3>
<p>当所有的 Controller 正常运行后，etcd 中就会保存一个 Deployment、一个 ReplicaSet 和 三个 Pod 资源记录，并且可以通过 kube-apiserver 查看。然而，这些 Pod 资源现在还处于 <code>Pending</code> 状态，因为它们还没有被调度到集群中合适的 Node 上运行。这个问题最终要靠调度器（Scheduler）来解决。</p>
<p><code>Scheduler</code> 作为一个独立的组件运行在集群控制平面上，工作方式与其他 Controller 相同：监听实际并将系统状态调整到期望的状态。具体来说，Scheduler 的作用是将待调度的 Pod 按照特定的算法和调度策略绑定（Binding）到集群中某个合适的 Node 上，并将绑定信息写入 etcd 中（它会过滤其 PodSpec 中 <code>NodeName</code> 字段为空的 Pod），默认的调度算法的工作方式如下：</p>
<ol>
<li>当 Scheduler 启动时，会<a href="https://github.com/kubernetes/kubernetes/blob/2d64ce5e8e45e26b02492d2b6c85e5ebfb1e4761/plugin/pkg/scheduler/algorithmprovider/defaults/defaults.go#L65-L81">注册一个默认的预选策略链</a>，这些 <code>预选策略</code> 会对备选节点进行评估，判断备选节点是否<a href="https://github.com/kubernetes/kubernetes/blob/2d64ce5e8e45e26b02492d2b6c85e5ebfb1e4761/plugin/pkg/scheduler/core/generic_scheduler.go#L117">满足备选 Pod 的需求</a>。例如，如果 PodSpec 字段限制了 CPU 和内存资源，那么当备选节点的资源容量不满足备选 Pod 的需求时，备选 Pod 就不会被调度到该节点上（<strong>资源容量=备选节点资源总量-节点中已存在 Pod 的所有容器的需求资源（CPU 和内存）的总和</strong>）</li>
<li>一旦筛选出符合要求的候选节点，就会采用 <code>优选策略</code> 计算出每个候选节点的积分，然后对这些候选节点进行排序，积分最高者胜出。例如，为了在整个系统中分摊工作负载，这些优选策略会从备选节点列表中选出资源消耗最小的节点。每个节点通过优选策略时都会算出一个得分，计算各项得分，最终选出分值大的节点作为优选的结果。</li>
</ol>
<p>一旦找到了合适的节点，Scheduler 就会创建一个 <code>Binding</code> 对象，该对象的 <code>Name</code> 和 <code>Uid</code> 与 Pod 相匹配，并且其 <code>ObjectReference</code> 字段包含所选节点的名称，然后通过 <code>POST</code> 请求<a href="https://github.com/kubernetes/kubernetes/blob/2d64ce5e8e45e26b02492d2b6c85e5ebfb1e4761/plugin/pkg/scheduler/factory/factory.go#L1095">发送给 apiserver</a>。</p>
<p>当 kube-apiserver 接收到此 Binding 对象时，注册吧会将该对象<strong>反序列化</strong>并更新 Pod 资源中的以下字段：</p>
<ul>
<li>将 <code>NodeName</code> 的值设置为 ObjectReference 中的 NodeName。</li>
<li>添加相关的注释。</li>
<li>将 <code>PodScheduled</code> 的 <code>status</code> 值设置为 True。可以通过 kubectl 来查看：</li>
</ul>
<pre><code class="language-bash">$ kubectl get &lt;PODNAME&gt; -o go-template='{{range .status.conditions}}{{if eq .type &quot;PodScheduled&quot;}}{{.status}}{{end}}{{end}}'
</code></pre>
<p>一旦 Scheduler 将 Pod 调度到某个节点上，该节点的 <code>Kubelet</code> 就会接管该 Pod 并开始部署。</p>
<p>预选策略和优选策略都可以通过 <code>–policy-config-file</code> 参数来扩展，如果默认的调度器不满足要求，还可以部署自定义的调度器。如果 <code>podSpec.schedulerName</code> 的值设置为其他的调度器，则 Kubernetes 会将该 Pod 的调度转交给那个调度器。</p>
<h2 id="kubelet">Kubelet</h2>
<hr>
<h3 id="pod-同步">Pod 同步</h3>
<p>现在，所有的 Controller 都完成了工作，我们来总结一下：</p>
<ul>
<li>HTTP 请求通过了认证、授权和准入控制阶段。</li>
<li>一个 Deployment、ReplicaSet 和三个 Pod 资源被持久化到 etcd 存储中。</li>
<li>然后运行了一系列Initializers。</li>
<li>最后每个 Pod 都被调度到合适的节点。</li>
</ul>
<p>然而到目前为止，所有的状态变化仅仅只是针对保存在 etcd 中的资源记录，接下来的步骤涉及到运行在工作节点之间的 Pod 的分布状况，这是分布式系统（比如 Kubernetes）的关键因素。这些任务都是由 <code>Kubelet</code> 组件完成的，让我们开始吧！</p>
<p>在 Kubernetes 集群中，每个 Node 节点上都会启动一个 Kubelet 服务进程，该进程用于处理 Scheduler 下发到本节点的任务，管理 Pod 的生命周期，包括挂载卷、容器日志记录、垃圾回收以及其他与 Pod 相关的事件。</p>
<p>如果换一种思维模式，你可以把 Kubelet 当成一种特殊的 Controller，它每隔 20 秒（可以自定义）向 kube-apiserver 通过 <code>NodeName</code> 获取自身 Node 上所要运行的 Pod 清单。一旦获取到了这个清单，它就会通过与自己的内部缓存进行比较来检测新增加的 Pod，如果有差异，就开始同步 Pod 列表。我们来详细分析一下同步过程：</p>
<ol>
<li>如果 Pod 正在创建， Kubelet 就会<a href="https://github.com/kubernetes/kubernetes/blob/fc8bfe2d8929e11a898c4557f9323c482b5e8842/pkg/kubelet/kubelet.go#L1519">记录一些在 <code>Prometheus</code> 中用于追踪 Pod 启动延时的指标</a>。</li>
<li>然后生成一个 <code>PodStatus</code> 对象，它表示 Pod 当前阶段的状态。Pod 的状态(<code>Phase</code>) 是 Pod 在其生命周期中的最精简的概要，包括 <code>Pending</code>，<code>Running</code>，<code>Succeeded</code>，<code>Failed</code> 和 <code>Unkown</code> 这几个值。状态的产生过程非常过程，所以很有必要深入了解一下背后的原理：</li>
</ol>
<ul>
<li>
<p>首先串行执行一系列 Pod 同步处理器（<code>PodSyncHandlers</code>），每个处理器检查检查 Pod 是否应该运行在该节点上。当所有的处理器都认为该 Pod 不应该运行在该节点上，则 Pod 的 <code>Phase</code> 值就会变成 <code>PodFailed</code>，并且将该 Pod 从该节点上驱逐出去。例如当你创建一个 <code>Job</code> 时，如果 Pod 失败重试的时间超过了 <code>spec.activeDeadlineSeconds</code> 设置的值，就会将 Pod 从该节点驱逐出去。</p>
</li>
<li>
<p>接下来，Pod 的 Phase 值由 <code>init 容器</code> 和应用容器的状态共同来决定。因为目前容器还没有启动，容器被视为<a href="https://github.com/kubernetes/kubernetes/blob/fc8bfe2d8929e11a898c4557f9323c482b5e8842/pkg/kubelet/kubelet_pods.go#L1244">处于等待阶段</a>，如果 Pod 中至少有一个容器处于等待阶段，则其 <code>Phase</code> 值为 <a href="https://github.com/kubernetes/kubernetes/blob/fc8bfe2d8929e11a898c4557f9323c482b5e8842/pkg/kubelet/kubelet_pods.go#L1258-L1261">Pending</a>。</p>
</li>
<li>
<p>最后，Pod 的 <code>Condition</code> 字段由 Pod 内所有容器的状态决定。现在我们的容器还没有被容器运行时创建，所以 <a href="https://github.com/kubernetes/kubernetes/blob/fc8bfe2d8929e11a898c4557f9323c482b5e8842/pkg/kubelet/status/generate.go#L70-L81"><code>PodReady</code> 的状态被设置为 <code>False</code></a>。可以通过 kubectl 查看：</p>
<pre><code class="language-bash">$ kubectl get &lt;PODNAME&gt; -o go-template='{{range .status.conditions}}{{if eq .type &quot;Ready&quot;}}{{.status}}{{end}}{{end}}'
</code></pre>
</li>
</ul>
<ol>
<li>生成 PodStatus 之后（Pod 中的 <code>status</code> 字段），Kubelet 就会将它发送到 Pod 的状态管理器，该管理器的任务是通过 apiserver 异步更新 etcd 中的记录。</li>
<li>接下来运行一系列<strong>准入处理器</strong>来确保该 Pod 是否具有相应的权限（包括强制执行 <a href="https://github.com/kubernetes/kubernetes/blob/fc8bfe2d8929e11a898c4557f9323c482b5e8842/pkg/kubelet/kubelet.go#L883-L884"><code>AppArmor</code> 配置文件和 <code>NO_NEW_PRIVS</code></a>），被准入控制器拒绝的 Pod 将一直保持 <code>Pending</code> 状态。</li>
<li>如果 Kubelet 启动时指定了 <code>cgroups-per-qos</code> 参数，Kubelet 就会为该 Pod 创建 <code>cgroup</code> 并进行相应的资源限制。这是为了更方便地对 Pod 进行服务质量（QoS）管理。</li>
<li>然后为 Pod 创建相应的目录，包括 Pod 的目录（<code>/var/run/kubelet/pods/&lt;podID&gt;</code>），该 Pod 的卷目录（<code>&lt;podDir&gt;/volumes</code>）和该 Pod 的插件目录（<code>&lt;podDir&gt;/plugins</code>）。</li>
<li><strong>卷管理器</strong>会<a href="https://github.com/kubernetes/kubernetes/blob/2723e06a251a4ec3ef241397217e73fa782b0b98/pkg/kubelet/volumemanager/volume_manager.go#L330">挂载 <code>Spec.Volumes</code> 中定义的相关数据卷，然后等待是否挂载成功</a>。根据挂载卷类型的不同，某些 Pod 可能需要等待更长的时间（比如 NFS 卷）。</li>
<li><a href="https://github.com/kubernetes/kubernetes/blob/dd9981d038012c120525c9e6df98b3beb3ef19e1/pkg/kubelet/kubelet_pods.go#L788">从 apiserver 中检索</a> <code>Spec.ImagePullSecrets</code> 中定义的所有 <code>Secret</code>，然后将其注入到容器中。</li>
<li>最后通过容器运行时接口（<code>Container Runtime Interface（CRI）</code>）开始启动容器（下面会详细描述）。</li>
</ol>
<h3 id="cri-与-pause-容器">CRI 与 pause 容器</h3>
<p>到了这个阶段，大量的初始化工作都已经完成，容器已经准备好开始启动了，而容器是由<strong>容器运行时</strong>（例如 <code>Docker</code> 和 <code>Rkt</code>）启动的。</p>
<p>为了更容易扩展，Kubelet 从 1.5.0 开始通过<strong>容器运行时接口</strong>与容器运行时（Container Runtime）交互。简而言之，CRI 提供了 Kubelet 和特定的运行时之间的抽象接口，它们之间通过<a href="https://github.com/google/protobuf">协议缓冲区</a>（它像一个更快的 JSON）和 <a href="https://grpc.io/">gRPC API</a>（一种非常适合执行 Kubernetes 操作的 API）。这是一个非常酷的想法，通过使用 Kubelet 和运行时之间定义的契约关系，容器如何编排的具体实现细节已经变得无关紧要。由于不需要修改 Kubernetes 的核心代码，开发者可以以最小的开销添加新的运行时。</p>
<p>不好意思有点跑题了，让我们继续回到容器启动的阶段。第一次启动 Pod 时，Kubelet 会通过 <code>Remote Procedure Command</code>(RPC) 协议调用 <a href="https://github.com/kubernetes/kubernetes/blob/2d64ce5e8e45e26b02492d2b6c85e5ebfb1e4761/pkg/kubelet/kuberuntime/kuberuntime_sandbox.go#L51">RunPodSandbox</a>。<code>sandbox</code> 用于描述一组容器，例如在 Kubernetes 中它表示的是 Pod。<code>sandbox</code> 是一个很宽泛的概念，所以对于其他没有使用容器的运行时仍然是有意义的（比如在一个基于 <code>hypervisor</code> 的运行时中，sandbox 可能指的就是虚拟机）。</p>
<p>我们的例子中使用的容器运行时是 Docker，创建 sandbox 时首先创建的是 <code>pause</code> 容器。pause 容器作为同一个 Pod 中所有其他容器的基础容器，它为 Pod 中的每个业务容器提供了大量的 Pod 级别资源，这些资源都是 Linux 命名空间（包括网络命名空间，IPC 命名空间和 PID 命名空间）。</p>
<p>pause 容器提供了一种方法来管理所有这些命名空间并允许业务容器共享它们，在同一个网络命名空间中的好处是：同一个 Pod 中的容器可以使用 <code>localhost</code> 来相互通信。pause 容器的第二个功能与 PID 命名空间的工作方式相关，在 PID 命名空间中，进程之间形成一个树状结构，一旦某个子进程由于父进程的错误而变成了“孤儿进程”，其便会被 <code>init</code> 进程进行收养并最终回收资源。关于 pause 工作方式的详细信息可以参考：<a href="https://www.ianlewis.org/en/almighty-pause-container">The Almighty Pause Container</a>。</p>
<p>一旦创建好了 pause 容器，下面就会开始检查磁盘状态然后开始启动业务容器。</p>
<h3 id="cni-和-pod-网络">CNI 和 Pod 网络</h3>
<p>现在我们的 Pod 已经有了基本的骨架：一个共享所有命名空间以允许业务容器在同一个 Pod 里进行通信的 pause 容器。但现在还有一个问题，那就是容器的网络是如何建立的？</p>
<p>当 Kubelet 为 Pod 创建网络时，它会将创建网络的任务交给 <code>CNI</code> 插件。CNI 表示容器网络接口（Container Network Interface），和容器运行时的运行方式类似，它也是一种抽象，允许不同的网络提供商为容器提供不同的网络实现。通过将 json 配置文件（默认在 <code>/etc/cni/net.d</code> 路径下）中的数据传送到相关的 CNI 二进制文件（默认在 <code>/opt/cni/bin</code> 路径下）中，cni 插件可以给 pause 容器配置相关的网络，然后 Pod 中其他的容器都使用 pause 容器的网络。下面是一个简单的示例配置文件：</p>
<pre><code class="language-json">{
    &quot;cniVersion&quot;: &quot;0.3.1&quot;,
    &quot;name&quot;: &quot;bridge&quot;,
    &quot;type&quot;: &quot;bridge&quot;,
    &quot;bridge&quot;: &quot;cnio0&quot;,
    &quot;isGateway&quot;: true,
    &quot;ipMasq&quot;: true,
    &quot;ipam&quot;: {
        &quot;type&quot;: &quot;host-local&quot;,
        &quot;ranges&quot;: [
          [{&quot;subnet&quot;: &quot;${POD_CIDR}&quot;}]
        ],
        &quot;routes&quot;: [{&quot;dst&quot;: &quot;0.0.0.0/0&quot;}]
    }
}
</code></pre>
<p>CNI 插件还会通过 <code>CNI_ARGS</code> 环境变量为 Pod 指定其他的元数据，包括 Pod 名称和命名空间。</p>
<p>下面的步骤因 CNI 插件而异，我们以 <code>bridge</code> 插件举例：</p>
<ul>
<li>该插件首先会在根网络命名空间（也就是宿主机的网络命名空间）中设置本地 Linux 网桥，以便为该主机上的所有容器提供网络服务。</li>
<li>然后它会将一个网络接口（<code>veth</code> 设备对的一端）插入到 pause 容器的网络命名空间中，并将另一端连接到网桥上。你可以这样来理解 veth 设备对：它就像一根很长的管道，一端连接到容器，一端连接到根网络命名空间中，数据包就在管道中进行传播。</li>
<li>接下来 json 文件中指定的 <code>IPAM</code> Plugin 会为 pause 容器的网络接口分配一个 IP 并设置相应的路由，现在 Pod 就有了自己的 IP。
<ul>
<li>IPAM Plugin 的工作方式和 CNI Plugin 类似：通过二进制文件调用并具有标准化的接口，每一个 IPAM Plugin 都必须要确定容器网络接口的 IP、子网以及网关和路由，并将信息返回给 CNI 插件。最常见的 IPAM Plugin 是 <code>host-local</code>，它从预定义的一组地址池中为容器分配 IP 地址。它将地址池的信息以及分配信息保存在主机的文件系统中，从而确保了同一主机上每个容器的 IP 地址的唯一性。</li>
</ul>
</li>
<li>最后 Kubelet 会将集群内部的 <code>DNS</code> 服务器的 <code>Cluster IP</code> 地址传给 CNI 插件，然后 CNI 插件将它们写到容器的 <code>/etc/resolv.conf</code> 文件中。</li>
</ul>
<p>一旦完成了上面的步骤，CNI 插件就会将操作的结果以 json 的格式返回给 Kubelet。</p>
<h3 id="跨主机容器网络">跨主机容器网络</h3>
<p>到目前为止，我们已经描述了容器如何与宿主机进行通信，但跨主机之间的容器如何通信呢？</p>
<p>通常情况下使用 <code>overlay</code> 网络来进行跨主机容器通信，这是一种动态同步多个主机间路由的方法。 其中最常用的 overlay 网络插件是 <code>flannel</code>，flannel 具体的工作方式可以参考 <a href="https://github.com/coreos/flannel">CoreOS 的文档</a>。</p>
<h3 id="容器启动">容器启动</h3>
<p>所有网络都配置完成后，接下来就开始真正启动业务容器了！</p>
<p>一旦 sanbox 完成初始化并处于 <code>active</code> 状态，Kubelet 就可以开始为其创建容器了。首先<a href="https://github.com/kubernetes/kubernetes/blob/5adfb24f8f25a0d57eb9a7b158db46f9f46f0d80/pkg/kubelet/kuberuntime/kuberuntime_manager.go#L690">启动 PodSpec 中定义的 init 容器</a>，然后再启动业务容器。具体过程如下：</p>
<ol>
<li>首先拉取容器的镜像。如果是私有仓库的镜像，就会利用 PodSpec 中指定的 Secret 来拉取该镜像。</li>
<li>然后通过 CRI 接口创建容器。Kubelet 向 PodSpec 中填充了一个 <code>ContainerConfig</code> 数据结构（在其中定义了命令，镜像，标签，挂载卷，设备，环境变量等待），然后通过 <code>protobufs</code> 发送给 CRI 接口。对于 Docker 来说，它会将这些信息反序列化并填充到自己的配置信息中，然后再发送给 <code>Dockerd</code> 守护进程。在这个过程中，它会将一些元数据标签（例如容器类型，日志路径，dandbox ID 等待）添加到容器中。</li>
<li>接下来会使用 CPU 管理器来约束容器，这是 Kubelet 1.8 中新添加的 alpha 特性，它使用 <code>UpdateContainerResources</code> CRI 方法将容器分配给本节点上的 CPU 资源池。</li>
<li>最后容器开始真正<a href="https://github.com/kubernetes/kubernetes/blob/5f9f4a1c5939436fa320e9bc5973a55d6446e59f/pkg/kubelet/kuberuntime/kuberuntime_container.go#L135">启动</a>。</li>
<li>如果 Pod 中配置了容器生命周期钩子（Hook），容器启动之后就会运行这些 <code>Hook</code>。Hook 的类型包括两种：<code>Exec</code>（执行一段命令） 和 <code>HTTP</code>（发送HTTP请求）。如果 PostStart Hook 启动的时间过长、挂起或者失败，容器将永远不会变成 <code>running</code> 状态。</li>
</ol>
<h2 id="一图看懂过程">一图看懂过程</h2>
<p>链接：<a href="https://hugo-picture.oss-cn-beijing.aliyuncs.com/what-happens-when-k8s.svg">图片地址</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue]]></title>
        <id>https://www.jianso.tech/lab/post/vue/</id>
        <link href="https://www.jianso.tech/lab/post/vue/">
        </link>
        <updated>2020-08-17T16:00:00.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1vue-概述">1.vue 概述</h1>
<p>html +css+js 视图 ：给用户看，刷新后台给的数据</p>
<p>网络通信 ：axios</p>
<p>页面跳转：vue -router</p>
<p>状态管理：vuex</p>
<p>Vue-UI: ice</p>
<p>webpack 打包</p>
<p>mvvm vm数据双向绑定</p>
<p>虚拟dom：利用内存</p>
<p>大前端时代</p>
<h2 id="11-什么是mvvm">1.1、什么是MVVM</h2>
<p>​		MVVM（Model-View-ViewModel）是一种软件设计模式，由微软WPF（用于替代WinForm，以前就是用这个技术开发桌面应用程序的）和Silverlight（类似于Java Applet，简单点说就是在浏览器上运行WPF）的架构师Ken Cooper和Ted Peters开发，是一种简化用户界面的<strong>事件驱动编程方式</strong>。由John Gossman（同样也是WPF和Sliverlight的架构师）与2005年在他的博客上发表。</p>
<p>MVVM源自于经典的MVC（Model-View-Controller）模式。MVVM的核心是ViewModel层，负责转换Model中的数据对象来让数据变得更容易管理和使用。其作用如下：</p>
<ul>
<li>该层向上与视图层进行双向数据绑定</li>
<li>向下与Model层通过接口请求进行数据交互</li>
</ul>
<figure data-type="image" tabindex="1"><img src="http://img.yanjiemao.top/20200615175823742.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>MVVM已经相当成熟了，主要运用但不仅仅在网络应用程序开发中。当下流行的MVVM框架有<code>Vue.js</code>，<code>Anfular JS</code></p>
<h2 id="12-为什么要使用mvvm">1.2、为什么要使用MVVM</h2>
<p>MVVM模式和MVC模式一样，主要目的是分离视图（View）和模型（Model），有几大好处</p>
<ul>
<li><strong>低耦合</strong>： 视图（view）可以独立于Model变化和修改，一个ViewModle可以绑定到不同的View上，当VIew变化的时候Modle可以不变，当Model变化的时候View也可以不变</li>
<li><strong>可复用</strong>：可以把一些视图逻辑放置在ViewModle里边，让很多View重用这段视图</li>
<li><strong>独立开发</strong>：开发人员专注于业务逻辑和数据的开发（ViewMode）,设计人员专注于页面设计</li>
<li>容易测试：界面元素难以测试，现在可以针对viewmode来写测试代码</li>
</ul>
<figure data-type="image" tabindex="2"><img src="/img/2020061517580183.png" alt="在这里插入图片描述" loading="lazy"></figure>
<blockquote>
<p>view</p>
</blockquote>
<p>View是视图层， 也就是用户界面。前端主要由HTH L和csS来构建， 为了更方便地展现vi eu to del或者Hodel层的数据， 已经产生了各种各样的前后端模板语言， 比如FreeMarker，Thyme leaf等等， 各大MV VM框架如Vue.js.Angular JS， EJS等也都有自己用来构建用户界面的内置模板语言。</p>
<blockquote>
<p>Model</p>
</blockquote>
<p>Model是指数据模型， 泛指后端进行的各种业务逻辑处理和数据操控， 主要围绕数据库系统展开。这里的难点主要在于需要和前端约定统一的接口规则</p>
<blockquote>
<p>ViewModel</p>
</blockquote>
<p>ViewModel是由前端开发人员组织生成和维护的视图数据层。在这一层， 前端开发者对从后端获取的Model数据进行转换处理， 做二次封装， 以生成符合View层使用预期的视图数据模型。<br>
  需要注意的是View Model所封装出来的数据模型包括视图的状态和行为两部分， 而Model层的数据模型是只包含状态的</p>
<ul>
<li>比如页面的这一块展示什么，那一块展示什么这些都属于视图状态(展示)</li>
<li>页面加载进来时发生什么，点击这一块发生什么，这一块滚动时发生什么这些都属于视图行为(交互)</li>
</ul>
<p>视图状态和行为都封装在了View Model里。这样的封装使得View Model可以完整地去描述View层。由于实现了双向绑定， View Model的内容会实时展现在View层， 这是激动人心的， 因为前端开发者再也不必低效又麻烦地通过操纵DOM去更新视图。<br>
  MVVM框架已经把最脏最累的一块做好了， 我们开发者只需要处理和维护View Model， 更新数据视图就会自动得到相应更新，真正实现<code>事件驱动编程</code>。<br>
  View层展现的不是<code>Model</code>层的数据， 而是<code>ViewModel</code>的数据， 由<code>ViewModel</code>负责与<code>Model</code>层交互， 这就<strong>完全解耦了View层和Model层， 这个解耦是至关重要的， 它是前后端分离方案实施的重要一环。</strong></p>
<h2 id="13-什么是vue">1.3、什么是Vue</h2>
<p>Vue(读音/vju/， 类似于view) 是一套用于构建用户界面的渐进式框架， 发布于2014年2月。与其它大型框架不同的是， Vue被设计为可以自底向上逐层应用。Vue的核心库只关注视图层， 不仅易于上手， 还便于与第三方库(如：vue-router，vue-resource，vue x) 或既有项目整合。</p>
<blockquote>
<p>MVVM模式的实现者</p>
</blockquote>
<ul>
<li>Model：模型层， 在这里表示JavaScript对象</li>
<li>View：视图层， 在这里表示DOM(HTML操作的元素)</li>
<li>ViewModel：连接视图和数据的中间件， Vue.js就是MVVM中的View Model层的实现者</li>
</ul>
<p>在MVVM架构中， 是不允许数据和视图直接通信的， 只能通过ViewModel来通信， 而View Model就是定义了一个Observer观察者</p>
<ul>
<li>ViewModel能够观察到数据的变化， 并对视图对应的内容进行更新</li>
<li>ViewModel能够监听到视图的变化， 并能够通知数据发生改变</li>
</ul>
<p>至此， 我们就明白了， Vue.js就是一个MV VM的实现者， 他的核心就是实现了DOM监听与数据绑定</p>
<blockquote>
<p>为什么使用Vue.js</p>
</blockquote>
<ul>
<li>轻量级， 体积小是一个重要指标。Vue.js压缩后有只有20多kb(Angular压缩后56kb+，React压缩后44kb+)</li>
<li>移动优先。更适合移动端， 比如移动端的Touch事件</li>
<li>易上手，学习曲线平稳，文档齐全</li>
<li>吸取了Angular(模块化) 和React(虚拟DOＭ) 的长处， 并拥有自己独特的功能，如：计算属性</li>
<li>开源，社区活跃度高</li>
</ul>
<h2 id="14-第一个vue程序">1.4、第一个Vue程序</h2>
<p>【说明】IDEA可以安装Vue的插件!<br>
注意：Vue不支持IE 8及以下版本， 因为Vue使用了IE 8无法模拟的ECMAScript 5特性。但它支持所有兼容ECMAScript 5的浏览器。</p>
<p><strong>下载版本</strong></p>
<ul>
<li>开发版本
<ul>
<li>包含完整的警告和调试模式：https：//yuejs.org/js/vue.js</li>
<li>删除了警告， 30.96KBmin+gzip：https：//vuejs.org/js/vue.min.js</li>
</ul>
</li>
<li>CDN
<ul>
<li><code>&lt;script src=“https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.js”&gt;&lt;/script&gt;</code></li>
<li><code>&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js&quot;&gt;&lt;/script&gt;</code></li>
</ul>
</li>
</ul>
<p>第一个程序</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;

&lt;/head&gt;hello2
&lt;body&gt;
&lt;h1&gt;郝大胖&lt;/h1&gt;
&lt;!--view层变成了模板--&gt;
&lt;div id=&quot;app&quot;&gt;
        {{message}}
&lt;/div&gt;


&lt;!--导入vue.js--&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    var vm = new Vue({
        el: &quot;#app&quot;,
        //modle,数据
        data: {
            message: &quot;hello,vue!&quot;
        }
    })
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ul>
<li><code>el: '#vue'</code>：绑定元素的ID</li>
<li><code>data:{message:'Hello Vue!'}</code>：数据对象中有一个名为message的属性，并设置了初始值 Hello Vue！</li>
</ul>
<p>说明：只需要在绑定的元素中使用双花括号将Vue创建的名为message属性包裹起来， 即可实现数据绑定功能， 也就实现了View Model层所需的效果， 是不是和EL表达式非常像?</p>
<blockquote>
<p>浏览器测试</p>
</blockquote>
<p>为了能够更直观的体验Vue带来的数据绑定功能， 我们需要在浏览器测试一番， 操作流程如下：<br>
  1、在浏览器上运行第一个Vue应用程序， 进入开发者工具<br>
  2、在控制台输入vm.message=‘HelloWorld’， 然后回车， 你会发现浏览器中显示的内容会直接变成HelloWorld<br>
  此时就可以在控制台直接输入vm.message来修改值， 中间是可以省略data的， 在这个操作中， 我并没有主动操作DOM， 就让页面的内容发生了变化， 这就是借助了Vue的数据绑定功能实现的； MV VM模式中要求View Model层就是使用观察者模式来实现数据的监听与绑定， 以做到数据与视图的快速响应。</p>
<h1 id="2基础语法指令">2.基础语法指令</h1>
<h2 id="21-v-bind">2.1、v-bind</h2>
<p>我们已经成功创建了第一个Vue应用!看起来这跟渲染一个字符串模板非常类似， 但是Vue在背后做了大量工作。现在数据和DOM已经被建立了关联， 所有东西都是响应式的。我们在控制台操作对象属性，界面可以实时更新!<br>
我们还可以使用v-bind来绑定元素特性!</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot; xmlns:v-bind=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;

&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;郝大胖&lt;/h1&gt;
&lt;!--view层变成了模板--&gt;
&lt;div id=&quot;app&quot;&gt;
    &lt;span v-bind:title=&quot;message&quot;&gt;
    鼠标悬停几秒
    &lt;/span&gt;
&lt;/div&gt;


&lt;!--导入vue.js--&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    var vm = new Vue({
        el: &quot;#app&quot;,
        //modle,数据
        data: {
            message: &quot;hello,vue!&quot;
        }
    })
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>​			你看到的v-bind等被称为指令。指令带有前缀v以表示它们是Vue提供的特殊特性。可能你已经猜到了， 它们会在渲染的DOM上应用特殊的响应式行为在这里，该指令的意思是：“将这个元素节点的title特性和Vue实例的message属性保持一致”。<br>
  如果你再次打开浏览器的JavaScript控制台， 输入app， message=‘新消息’，就会再一次看到这个绑定了title特性的HTML已经进行了更新。</p>
<h2 id="22-v-if-v-else">2.2、v-if v-else</h2>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot; xmlns:v-bind=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;

&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;郝大胖&lt;/h1&gt;
&lt;!--view层变成了模板--&gt;
&lt;div id=&quot;app&quot;&gt;
   &lt;h1 v-if=&quot;type==='A'&quot;&gt;A&lt;/h1&gt;
   &lt;h1 v-else-if=&quot;type==='B'&quot;&gt;B&lt;/h1&gt;
   &lt;h1 v-else-if=&quot;type==='C'&quot;&gt;C&lt;/h1&gt;
   &lt;h1 v-else&gt;D&lt;/h1&gt;
&lt;/div&gt;


&lt;!--导入vue.js--&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    var vm = new Vue({
        el: &quot;#app&quot;,
        //modle,数据
        data: {
            type: 'A'
        }
    })
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>注：<code>===</code>三个等号在JS中表示绝对等于(就是数据与类型都要相等)上代码：</p>
<h2 id="23-v-for">2.3、v-for</h2>
<p>格式说明</p>
<p><code>items</code>是数组，<code>item</code>是数组元素迭代的别名。我们之后学习的Thymeleaf模板引擎的语法和这个十分的相似！</p>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
    &lt;li v-for=&quot;(item,index) in items&quot;&gt;
        {{item.message}}---{{index}}
    &lt;/li&gt;

&lt;/div&gt;
</code></pre>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot; xmlns:v-bind=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;

&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;郝大胖&lt;/h1&gt;
&lt;!--view层变成了模板--&gt;
&lt;div id=&quot;app&quot;&gt;
    &lt;li v-for=&quot;item in items&quot;&gt;
        {{item.message}}---{{index}}
    &lt;/li&gt;
&lt;/div&gt;


&lt;!--导入vue.js--&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    var vm = new Vue({
        el: &quot;#app&quot;,
        //modle,数据
        data: {
            items:[
                {message:'郝大胖'},
                {message:'啦啦啦'},
                {message:'呀呀呀'}

            ]
        }
    })
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>在控制台输入<code>vm.items.push({message：'你好呀'})</code>，尝试追加一条数据，你会发现浏览器中显示的内容会增加一条 你好呀.</p>
<h2 id="24-v-on">2.4、v-on</h2>
<p><code>v-on</code>监听事件<br>
 事件有Vue的事件、和前端页面本身的一些事件!我们这里的<code>click</code>是vue的事件， 可以绑定到Vue中的<code>methods</code>中的方法事件!</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot; xmlns:v-on=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;

&lt;/head&gt;
&lt;body&gt;

&lt;div id=&quot;app&quot;&gt;
&lt;button v-on:click=&quot;sayHi&quot;&gt;点我&lt;/button&gt;
&lt;/div&gt;


&lt;!--导入vue.js--&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    var vm = new Vue({
        el: &quot;#app&quot;,

        data: {
            message:&quot;郝大胖&quot;
        },
        methods:{//方法必须定义在Vue的Methods对象中
            sayHi: function (){
                alert(this.message);
            }

        }

    })
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>Vue还有一些基本的使用方式， 大家有需要的可以再跟着官方文档看看https://cn.vuejs.org/</p>
<h1 id="3表单双向数据绑定">3.表单双向数据绑定</h1>
<h2 id="31-什么是双向数据绑定">3.1、什么是双向数据绑定</h2>
<p>​		Vue.js是一个MV VM框架， 即数据双向绑定， 即当数据发生变化的时候， 视图也就发生变化， 当视图发生变化的时候，数据也会跟着同步变化。这也算是Vue.js的精髓之处了。<br>
  值得注意的是，我们所说的数据双向绑定，一定是对于UI控件来说的非UI控件不会涉及到数据双向绑定。单向数据绑定是使用状态管理工具的前提。如果我们使用vue x那么数据流也是单项的，这时就会和双向数据绑定有冲突。</p>
<p><strong>为什么要实现数据的双向绑定？</strong></p>
<p>在<code>Vue.js</code>中，如果使用<code>vuex</code>， 实际上数据还是单向的， 之所以说是数据双向绑定，这是用的UI控件来说， 对于我们处理表单， <code>Vue.js</code>的双向数据绑定用起来就特别舒服了。即两者并不互斥，在全局性数据流使用单项，方便跟踪；局部性数据流使用双向，简单易操作。</p>
<h2 id="32-在表单中使用双向数据绑定">3.2、在表单中使用双向数据绑定</h2>
<p>可以用<code>v-model</code>指令在表单、及元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇， 但<code>v-model</code>本质上不过是语法糖。它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。<br>
  注意：<code>v-model</code>会忽略所有表单元素的<code>value</code>、<code>checked</code>、<code>selected</code>特性的初始值而总是将<code>Vue</code>实例的数据作为数据来源。你应该通过<code>JavaScript</code>在组件的<code>data</code>选项中声明初始值!</p>
<p>1.单行文本</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id=&quot;app&quot;&gt;
    输入的文本：&lt;input type=&quot;text&quot; v-model=&quot;message&quot; value=&quot;hello&quot;&gt;{{message}}
&lt;/div&gt;

&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    var vm = new Vue({
        el:&quot;#app&quot;,
        data:{
            message:&quot;&quot;
        }
    });
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<p>2.多行文本</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id=&quot;app&quot;&gt;
   多行文本：&lt;textarea v-model=&quot;pan&quot;&gt;&lt;/textarea&gt;&amp;nbsp;&amp;nbsp;多行文本是：{{pan}}
&lt;/div&gt;

&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    var vm = new Vue({
        el:&quot;#app&quot;,
        data:{
            message:&quot;Hello hello!&quot;
        }
    });
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>3.单复选框</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div id=&quot;app&quot;&gt;
    单复选框：
    &lt;input type=&quot;checkbox&quot; id=&quot;checkbox&quot; v-model=&quot;checked&quot;&gt;
    &amp;nbsp;&amp;nbsp;
    &lt;label for=&quot;checkbox&quot;&gt;{{checked}}&lt;/label&gt;
&lt;/div&gt;

&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    var vm = new Vue({
        el:&quot;#app&quot;,
        data:{
            checked:false
        }
    });
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>4.多复选框</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div id=&quot;app&quot;&gt;
    多复选框：
    &lt;input type=&quot;checkbox&quot; id=&quot;jack&quot; value=&quot;Jack&quot; v-model=&quot;checkedNames&quot;&gt;
    &amp;nbsp;&amp;nbsp;
    &lt;label for=&quot;jack&quot;&gt;Jack&lt;/label&gt;
    &lt;input type=&quot;checkbox&quot; id=&quot;join&quot; value=&quot;Join&quot; v-model=&quot;checkedNames&quot;&gt;
    &amp;nbsp;&amp;nbsp;
    &lt;label for=&quot;join&quot;&gt;Jack&lt;/label&gt;
    &lt;input type=&quot;checkbox&quot; id=&quot;mike&quot; value=&quot;Mike&quot; v-model=&quot;checkedNames&quot;&gt;
    &amp;nbsp;&amp;nbsp;
    &lt;label for=&quot;mike&quot;&gt;Mike&lt;/label&gt;
    &lt;span&gt;选中的值：{{checkedNames}}&lt;/span&gt;
&lt;/div&gt;

&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    var vm = new Vue({
        el:&quot;#app&quot;,
        data:{
            checkedNames:[]
        }
    });
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>5.单选按钮</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div id=&quot;app&quot;&gt;
    单选框按钮
    &lt;input type=&quot;radio&quot; id=&quot;one&quot; value=&quot;One&quot; v-model=&quot;picked&quot;&gt;
    &lt;label for=&quot;one&quot;&gt;One&lt;/label&gt;
    &lt;input type=&quot;radio&quot; id=&quot;two&quot; value=&quot;Two&quot; v-model=&quot;picked&quot;&gt;
    &lt;label for=&quot;two&quot;&gt;Two&lt;/label&gt;
    &lt;span&gt;选中的值：{{picked}}&lt;/span&gt;
&lt;/div&gt;

&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    var vm = new Vue({
        el:&quot;#app&quot;,
        data:{
            picked:'Two'
        }
    });
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>6.下拉框</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id=&quot;app&quot;&gt;

    下拉框:
    &lt;select v-model=&quot;pan&quot;&gt;
        &lt;option value=&quot;&quot; disabled&gt;---请选择---&lt;/option&gt;
        &lt;option&gt;A&lt;/option&gt;
        &lt;option&gt;B&lt;/option&gt;
        &lt;option&gt;C&lt;/option&gt;
        &lt;option&gt;D&lt;/option&gt;
    &lt;/select&gt;
    &lt;span&gt;value:{{pan}}&lt;/span&gt;



&lt;/div&gt;

&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    var vm = new Vue({
        el:&quot;#app&quot;,
        data:{
            pan:&quot;A&quot;
        }
    });
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>注意：<code>v-model</code>表达式的初始值未能匹配任何选项，元系将被渲染为“未选中”状态。 在iOS中， 这会使用户无法选择第一个选项，因为这样的情况下，iOS不会触发<code>change</code>事件。因此，更推荐像上面这样提供一个值为空的禁用选项。</p>
<h1 id="4组件">4.组件</h1>
<h2 id="41-什么是组件">4.1、什么是组件</h2>
<p>组件是可复用的<code>Vue</code>实例， 说白了就是一组可以重复使用的模板， 跟<code>JSTL</code>的自定义标签、<code>Thymeleal</code>的<code>th:fragment</code>等框架有着异曲同工之妙，通常一个应用会以一棵嵌套的组件树的形式来组织：</p>
<figure data-type="image" tabindex="3"><img src="http://img.yanjiemao.top/20200616171528707.png" alt="在这里插入图片描述" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="http://img.yanjiemao.top/20200616171908189.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>例如，你可能会有页头、侧边栏、内容区等组件，每个组件又包含了其它的像导航链接、博文之类的组件。</p>
<h2 id="42-第一个组件">4.2、第一个组件</h2>
<p>注意：在实际开发中，我们并不会用以下方式开发组件，而是采用<code>vue-cli</code>创建，<code>vue</code>模板文件的方式开发，以下方法只是为了让大家理解什么是组件。</p>
<p><strong>使用<code>Vue.component()</code>方法注册组件，格式如下：</strong></p>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
  &lt;pan&gt;&lt;/pan&gt;
&lt;/div&gt;

&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    //先注册组件
    Vue.component(&quot;pan&quot;,{
        
        template:'&lt;li&gt;Hello&lt;/li&gt;'

    });
    //再实例化Vue
    var vm = new Vue({
        el:&quot;#app&quot;,
    });
&lt;/script&gt;

</code></pre>
<p>说明：</p>
<ul>
<li><code>Vue.component()</code>：注册组件</li>
<li><code>pan</code>：自定义组件的名字</li>
<li><code>template</code>：组件的模板</li>
</ul>
<h2 id="43-使用props传递参数">4.3、使用props传递参数</h2>
<p>像上面那样用组件没有任何意义，所以我们是需要传递参数到组件的，此时就需要使用<code>props</code>属性了！<br>
<strong>注意：默认规则下props属性里的值不能为大写；</strong></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot; xmlns:v-on=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;

&lt;/head&gt;
&lt;body&gt;

&lt;div id=&quot;app&quot;&gt;
&lt;!--    组件，传递给组件中的值：props--&gt;
    &lt;hao v-for=&quot;item in items&quot; v-bind:haodapang=&quot;item&quot;&gt;&lt;/hao&gt;

&lt;/div&gt;


&lt;!--导入vue.js--&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    //定义一个Vue组件component
    Vue.component(&quot;hao&quot;,{
        props: ['haodapang'],
        template: '&lt;li&gt;{{haodapang}}&lt;/li&gt;'

    });
    var vm = new Vue({
        el: &quot;#app&quot;,
        data:{
            items: [&quot;java&quot;,&quot;linux&quot;,&quot;前端&quot;]
        }

    });
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><strong>说明</strong>：</p>
<ul>
<li><code>v-for=&quot;item in items&quot;</code>：遍历<code>Vue</code>实例中定义的名为<code>items</code>的数组，并创建同等数量的组件</li>
<li><code>v-bind:haodapang=&quot;item&quot;</code>：将遍历的<code>item</code>项绑定到组件中<code>props</code>定义名为<code>item</code>属性上；= 号左边的<code>haodapang</code>为<code>props</code>定义的属性名，右边的为<code>item in items</code> 中遍历的item项的值</li>
</ul>
<h1 id="5axios异步通信">5.Axios异步通信</h1>
<h2 id="51-什么是axios">5.1、什么是Axios</h2>
<p>Axios是一个开源的可以用在浏览器端和<code>Node JS</code>的异步通信框架， 她的主要作用就是实现AJAX异步通信，其功能特点如下：</p>
<ul>
<li>从浏览器中创建<code>XMLHttpRequests</code></li>
<li>从node.js创建http请求</li>
<li>支持Promise API[JS中链式编程]</li>
<li>拦截请求和响应</li>
<li>转换请求数据和响应数据</li>
<li>取消请求</li>
<li>自动转换JSON数据</li>
<li>客户端支持防御XSRF(跨站请求伪造)</li>
</ul>
<p>GitHub：https://github.com/axios/axios<br>
  中文文档：http://www.axios-js.com/</p>
<blockquote>
<p>为什么要使用Axios</p>
</blockquote>
<p>由于<code>Vue.js</code>是一个视图层框架并且作者(尤雨溪) 严格准守SoC(关注度分离原则)所以<code>Vue.js</code>并不包含AJAX的通信功能， 为了解决通信问题， 作者单独开发了一个名为<code>vue-resource</code>的插件， 不过在进入2.0版本以后停止了对该插件的维护并推荐了<code>Axios</code>框架。少用jQuery， 因为它操作Dom太频繁!</p>
<h2 id="52-第一个axios应用程序">5.2、第一个Axios应用程序</h2>
<p>咱们开发的接口大部分都是采用JSON格式， 可以先在项目里模拟一段JSON数据， 数据内容如下：创建一个名为data.json的文件并填入上面的内容， 放在项目的根目录下</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;郝大胖&quot;,
  &quot;url&quot;: &quot;https://blog.jianso.tech/&quot;,
  &quot;page&quot;: 1,
  &quot;isNonProfit&quot;: true,
  &quot;address&quot;: {
    &quot;street&quot;: &quot;光荣道&quot;,
    &quot;city&quot;: &quot;天津&quot;,
    &quot;country&quot;: &quot;中国&quot;
  }

}

</code></pre>
<p>测试代码</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div id=&quot;vue&quot;&gt;
    &lt;div&gt;名字：{{info.name}}&lt;/div&gt;
    &lt;div&gt;地址：{{info.address.street}}&lt;/div&gt;
    &lt;div&gt;链接：&lt;a v-binf:href=&quot;info.url&quot; target=&quot;_blank&quot;&gt;{{info.url}}&lt;/a&gt; &lt;/div&gt;
&lt;/div&gt;

&lt;!--引入js文件--&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    var vm = new Vue({
        el:&quot;#vue&quot;,
        //data: 属性 data方法
        data(){
            return{
                //请求的返回参数格适，必须和json字符串一样
                info:{
                    name: null,
                    address: {
                        street: null,
                        city: null,
                        country: null
                    }

                }

            }

        },
        mounted(){//钩子函数 链式编程 es6新特性
            axios.get('data.json').then(response=&gt;{this.info=(response.data)})

        }
    });

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>说明：</p>
<ol>
<li>在这里使用了v-bind将a:href的属性值与Vue实例中的数据进行绑定</li>
<li>使用axios框架的get方法请求AJAX并自动将数据封装进了Vue实例的数据对象中</li>
<li>我们在data中的数据结构必须和<code>Ajax</code>响应回来的数据格式匹配！</li>
</ol>
<h2 id="53-vue的生命周期">5.3、Vue的生命周期</h2>
<p>官方文档：https://cn.vuejs.org/v2/guide/instance.html#生命周期图示<br>
  Vue实例有一个完整的生命周期，也就是从开始创建初女台化数据、编译模板、挂载DOM、渲染一更新一渲染、卸载等一系列过程，我们称这是Vue的生命周期。通俗说就是Vue实例从创建到销毁的过程，就是生命周期。<br>
  在Vue的整个生命周期中，它提供了一系列的事件，可以让我们在事件触发时注册JS方法，可以让我们用自己注册的JS方法控制整个大局，在这些事件响应方法中的this直接指向的是Vue的实例。</p>
<figure data-type="image" tabindex="5"><img src="http://img.yanjiemao.top/20200616222020393.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="6计算属性-内容分发-自定义事件">6.计算属性、内容分发、自定义事件</h1>
<h2 id="61-什么是计算属性">6.1、什么是计算属性</h2>
<p>计算属性的重点突出在<code>属性</code>两个字上(属性是名词)，首先它是个<code>属性</code>其次这个属性有<code>计算</code>的能力(计算是动词)，这里的<code>计算</code>就是个函数：简单点说，它就是一个能够将计算结果缓存起来的属性(将行为转化成了静态的属性)，仅此而已；可以想象为缓存!</p>
<p>代码</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--view层，模板--&gt;
&lt;div id=&quot;app&quot;&gt;
    &lt;p&gt;currentTime1:{{currentTime1()}}&lt;/p&gt;
    &lt;p&gt;currentTime2:{{currentTime2}}&lt;/p&gt;
&lt;/div&gt;

&lt;!--1.导入Vue.js--&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    var vm = new Vue({
        el:&quot;#app&quot;,
        data:{
          message:&quot;pan&quot;
        },
        methods:{
            currentTime1:function(){
                return Date.now();//返回一个时间戳
            }
        },
        computed:{
            currentTime2:function(){//计算属性：methods，computed方法名不能重名，重名之后，只会调用methods的方法
                this.message;
                return Date.now();//返回一个时间戳
            }
        }
    });
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<p>注意：methods和computed里的东西不能重名</p>
<blockquote>
<p>说明：</p>
</blockquote>
<ul>
<li>
<p>methods：定义方法， 调用方法使用currentTime1()， 需要带括号</p>
</li>
<li>
<p>computed：定义计算属性， 调用属性使用currentTime2， 不需要带括号：this.message是为了能够让currentTime2观察到数据变化而变化</p>
</li>
<li>
<p>如何在方法中的值发生了变化，则缓存就会刷新!可以在控制台使用<code>vm.message=”q in jiang&quot;</code>， 改变下数据的值，再次测试观察效果!</p>
<p><strong>结论：</strong><br>
  调用方法时，每次都需要讲行计算，既然有计算过程则必定产生系统开销，那如果这个结果是不经常变化的呢?此时就可以考虑将这个结果缓存起来，采用计算属性可以很方便的做到这点，<strong>计算属性的主要特性就是为了将不经常变化的计算结果进行缓存，以节约我们的系统开销；</strong></p>
</li>
</ul>
<h2 id="62-内容分发">6.2、内容分发</h2>
<p>在<code>Vue.js</code>中我们使用<code>&lt;slot&gt;</code>元素作为承载分发内容的出口，作者称其为插槽，可以应用在组合组件的场景中；</p>
<p>举例</p>
<p>比如准备制作一个待办事项组件(todo) ， 该组件由待办标题(todo-title) 和待办内容(todo-items)组成，但这三个组件又是相互独立的，该如何操作呢?</p>
<p>第一步 定义一个待办事件的组件</p>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
    &lt;todo&gt;&lt;/todo&gt;
&lt;/div&gt;
&lt;!--1.导入Vue.js--&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    Vue.component('todo',{
        template:'&lt;div&gt;\
                &lt;div&gt;代办事项&lt;/div&gt;\
                &lt;ul&gt;\
                    &lt;li&gt;学习狂神说Java&lt;/li&gt;\
                &lt;/ul&gt;\
            &lt;/div&gt;'
    })
&lt;/script&gt;

</code></pre>
<p>第二步 我们需要让，代办事项的标题和值实现动态绑定，怎么做呢？我们可以留一个插槽！</p>
<p>1-将上面的代码留出一个插槽，即slot</p>
<pre><code class="language-html"> Vue.component('todo',{
        template:'&lt;div&gt;\
                &lt;slot name=&quot;todo-title&quot;&gt;&lt;/slot&gt;\
                &lt;ul&gt;\
                    &lt;slot name=&quot;todo-items&quot;&gt;&lt;/slot&gt;\
                &lt;/ul&gt;\
            &lt;/div&gt;'
    });

</code></pre>
<p>2-定义一个名为todo-title的待办标题组件 和 todo-items的待办内容组件</p>
<pre><code class="language-js">Vue.component('todo-title',{
props:['title'],
template:'&lt;div&gt;{{title}}&lt;/div&gt;'
});
//这里的index，就是数组的下标，使用for循环遍历的时候，可以循环出来！
Vue.component(&quot;todo-items&quot;,{
props:[&quot;item&quot;,&quot;index&quot;],
template:&quot;&lt;li&gt;{{index+1}},{{item}}&lt;/li&gt;&quot;
});
</code></pre>
<p>3-实例化Vue并初始化数据</p>
<pre><code class="language-js"> var vm = new Vue({
        el:&quot;#vue&quot;,
        data:{
            todoItems:['test1','test2','test3']
        }
    });

</code></pre>
<p>4-将这些值，通过插槽插入</p>
<pre><code class="language-js">&lt;div id=&quot;vue&quot;&gt;
    &lt;todo&gt;
        &lt;todo-title slot=&quot;todo-title&quot; title=&quot;郝大胖系列课程&quot;&gt;&lt;/todo-title&gt;
        &lt;!--&lt;todo-items slot=&quot;todo-items&quot; v-for=&quot;{item,index} in todoItems&quot; v-bind:item=&quot;item&quot;&gt;&lt;/todo-items&gt;--&gt;
        &lt;!--如下为简写--&gt;
        &lt;todo-items slot=&quot;todo-items&quot; v-for=&quot;item in todoItems&quot; :item=&quot;item&quot;&gt;&lt;/todo-items
    &lt;/todo&gt;
&lt;/div&gt;

</code></pre>
<p>说明：我们的todo-title和todo-items组件分别被分发到了todo组件的todo-title和todo-items插槽中</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--view层，模板--&gt;
&lt;div id=&quot;vue&quot;&gt;
    &lt;todo&gt;
        &lt;todo-title slot=&quot;todo-title&quot; title=&quot;title&quot;&gt;&lt;/todo-title&gt;
        &lt;!--&lt;todo-items slot=&quot;todo-items&quot; v-for=&quot;{item,index} in todoItems&quot; v-bind:item=&quot;item&quot;&gt;&lt;/todo-items&gt;--&gt;
        &lt;!--如下为简写--&gt;
        &lt;todo-items slot=&quot;todo-items&quot; v-for=&quot;item in todoItems&quot; :item=&quot;item&quot;&gt;&lt;/todo-items
    &lt;/todo&gt;
&lt;/div&gt;
&lt;!--1.导入Vue.js--&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    Vue.component('todo',{
        template:'&lt;div&gt;\
                &lt;slot name=&quot;todo-title&quot;&gt;&lt;/slot&gt;\
                &lt;ul&gt;\
                    &lt;slot name=&quot;todo-items&quot;&gt;&lt;/slot&gt;\
                &lt;/ul&gt;\
            &lt;/div&gt;'
    });
    Vue.component('todo-title',{
        props:['title'],
        template:'&lt;div&gt;{{title}}&lt;/div&gt;'
    });
    //这里的index，就是数组的下标，使用for循环遍历的时候，可以循环出来！
    Vue.component(&quot;todo-items&quot;,{
        props:[&quot;item&quot;,&quot;index&quot;],
        template:&quot;&lt;li&gt;{{index+1}},{{item}}&lt;/li&gt;&quot;
    });

    var vm = new Vue({
        el:&quot;#vue&quot;,
        data:{
            title:&quot;郝大胖系列课程&quot;,
            todoItems:['test1','test2','test3']
        }
    });
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<h2 id="63-自定义事件">6.3、自定义事件</h2>
<p>​    通以上代码不难发现，数据项在Vue的实例中， 但删除操作要在组件中完成， 那么组件如何才能删除Vue实例中的数据呢?此时就涉及到参数传递与事件分发了， Vue为我们提供了自定义事件的功能很好的帮助我们解决了这个问题； 使用this.$emit(‘自定义事件名’， 参数) ， 操作过程如下：<br>
1-在vue的实例中增加了methods对象并定义了一个名为removeTodoltems的方法</p>
<pre><code class="language-js">var vm = new Vue({
        el:&quot;#vue&quot;,
        data:{
            title_text:&quot;秦老师系列课程&quot;,
            todoItems:['test1','test2','test3']
        },
        methods:{
            removeItems:function(index){
                console.log(&quot;删除了&quot;+this.todoItems[index]+&quot;OK&quot;);
                //splice（） 方法向/从数组中添加/删除项目，然后返回被删除的项目，其中index
                this.todoItems.splice(index,1);
            }
        }
    });

</code></pre>
<p>2-修改todo-items待办内容组件的代码，增加一个删除按钮，并且绑定事件！</p>
<pre><code class="language-js"> Vue.component(&quot;todo-items&quot;,{
        props:[&quot;item_p&quot;,&quot;index_p&quot;],
        template:&quot;&lt;li&gt;{{index_p+1}},{{item_p}} &lt;button @click='remove'&gt;删除&lt;/button&gt;&lt;/li&gt;&quot;,
        methods:{
            remove:function (index) {
            //这里的remove是自定义事件名称，需要在HTML中使用v-on:remove的方式
                //this.$emit 自定义事件分发
                this.$emit('remove',index);
            }
        }
    });

</code></pre>
<p>3-修改todo-items待办内容组件的HTML代码，增加一个自定义事件，比如叫remove，可以和组件的方法绑定，然后绑定到vue的方法！</p>
<pre><code class="language-js">&lt;!--增加了v-on:remove=&quot;removeTodoItems(index)&quot;自定义事件，该组件会调用Vue实例中定义的--&gt;
&lt;todo-items slot=&quot;todo-items&quot; v-for=&quot;(item,index) in todoItems&quot;
                    :item_p=&quot;item&quot; :index_p=&quot;index&quot; v-on:remove=&quot;removeItems(index)&quot; :key=&quot;index&quot;&gt;&lt;/todo-items&gt;
 
</code></pre>
<p><strong>对上一个代码进行修改，实现删除功能</strong></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--view层，模板--&gt;
&lt;div id=&quot;vue&quot;&gt;
    &lt;todo&gt;
        &lt;todo-title slot=&quot;todo-title&quot; :title=&quot;title_text&quot;&gt;&lt;/todo-title&gt;
        &lt;!--&lt;todo-items slot=&quot;todo-items&quot; v-for=&quot;(item,index) in todoItems&quot; v-bind:item=&quot;item&quot;&gt;&lt;/todo-items&gt;--&gt;
        &lt;!--如下为简写--&gt;
        &lt;todo-items slot=&quot;todo-items&quot; v-for=&quot;(item,index) in todoItems&quot;
                    :item_p=&quot;item&quot; :index_p=&quot;index&quot; v-on:remove=&quot;removeItems(index)&quot; :key=&quot;index&quot;&gt;&lt;/todo-items&gt;
    &lt;/todo&gt;
&lt;/div&gt;
&lt;!--1.导入Vue.js--&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    Vue.component('todo',{
        template:'&lt;div&gt;\
                &lt;slot name=&quot;todo-title&quot;&gt;&lt;/slot&gt;\
                &lt;ul&gt;\
                    &lt;slot name=&quot;todo-items&quot;&gt;&lt;/slot&gt;\
                &lt;/ul&gt;\
            &lt;/div&gt;'
    });
    Vue.component('todo-title',{
        props:['title'],
        template:'&lt;div&gt;{{title}}&lt;/div&gt;'
    });
    //这里的index，就是数组的下标，使用for循环遍历的时候，可以循环出来！
    Vue.component(&quot;todo-items&quot;,{
        props:[&quot;item_p&quot;,&quot;index_p&quot;],
        template:&quot;&lt;li&gt;{{index_p+1}},{{item_p}} &lt;button @click='remove_methods'&gt;删除&lt;/button&gt;&lt;/li&gt;&quot;,
        methods:{
            remove_methods:function (index) {
                //this.$emit 自定义事件分发
                this.$emit('remove',index);
            }
        }
    });

    var vm = new Vue({
        el:&quot;#vue&quot;,
        data:{
            title_text:&quot;郝大胖系列课程&quot;,
            todoItems:['test1','test2','test3']
        },
        methods:{
            removeItems:function(index){
                console.log(&quot;删除了&quot;+this.todoItems[index]+&quot;OK&quot;);
                this.todoItems.splice(index,1);
            }
        }
    });
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<p>逻辑理解</p>
<figure data-type="image" tabindex="6"><img src="/img/image-20200927121637115.png" alt="image-20200927121637115" loading="lazy"></figure>
<h2 id="64-vue入门小结">6.4、vue入门小结</h2>
<p>核心：数据驱动，组件化</p>
<p>优点：借鉴了AngularJS的模块化开发和React的虚拟Dom，虚拟Dom就是把Demo操作放到内存中执行；</p>
<p>常用的属性：</p>
<ul>
<li>v-if</li>
<li>v-else-if</li>
<li>v-else</li>
<li>v-for</li>
<li>v-on绑定事件，简写@</li>
<li>v-model数据双向绑定</li>
<li>v-bind给巨剑绑定参数，简写：</li>
</ul>
<p>组件化：</p>
<ul>
<li>组合组件slot插槽</li>
<li>组件内部绑定事件需要使用到<code>this.$emit(&quot;事件名&quot;,参数);</code></li>
<li>计算属性的特色，缓存计算数据</li>
</ul>
<p>遵循SoC关注度分离原则，Vue是纯粹的视图框架，并不包含，比如Ajax之类的通信功能，为了解决通信问题，我们需要使用Axios框架做异步通信；</p>
<h2 id="说明">说明</h2>
<p>Vue的开发都是要基于NodeJS，实际开发采用Vue-cli脚手架开发，vue-router路由，vuex做状态管理；Vue UI，界面我们一般使用ElementUI（饿了么出品），或者ICE（阿里巴巴出品）来快速搭建前端项目~~</p>
<p>官网：</p>
<ul>
<li>https://element.eleme.cn/#/zh-CN</li>
<li>https://ice.work/</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSS3]]></title>
        <id>https://www.jianso.tech/lab/post/CSS3/</id>
        <link href="https://www.jianso.tech/lab/post/CSS3/">
        </link>
        <updated>2020-08-09T16:00:00.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1什么是css">1.什么是CSS</h1>
<h2 id="11-什么是css">1.1、什么是CSS</h2>
<p>Csscading Style Sheet 层叠级联样式表</p>
<p>CSS：表现（美化网页）</p>
<p>字体 、颜色、边距、高度、宽度、背景图片、网页定位、网页浮动···</p>
<h2 id="12-发展史">1.2、发展史</h2>
<p>CSS 1.0</p>
<p>CSS 2.0  DiV (块) +CSS，HTML与CSS结构分离的思想，   网页变得简单 、seo</p>
<p>CSS 2.1  浮动 定位</p>
<p>CSS 3.0  圆角 阴影，动画···</p>
<h2 id="13-快速入门">1.3 、快速入门</h2>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;!--规范，&lt;style&gt;可以编写css的代码
    语法：
        选择器｛
            声明1；
            声明2；
            声明3;

        ｝
    --&gt;
   &lt;style&gt;
   		h1{
   		 color: aqua;
	}
   &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt; 我是标题 &lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>建议用链接方式</p>
<figure data-type="image" tabindex="1"><img src="http://img.yanjiemao.top/image-20200820102938427.png" alt="image-20200820102938427" loading="lazy"></figure>
<p>CSS的优势</p>
<ol>
<li>内容和表现分离</li>
<li>网页结构表现统一，可以实现复用</li>
<li>样式十分丰富</li>
<li>建议使用独立于HTML的CSS文件</li>
<li>利用SEO，容易被搜索引擎收录</li>
</ol>
<h2 id="14-css的四种导入方式">1.4 、CSS的四种导入方式</h2>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;


&lt;!--内部样式--&gt;
    &lt;style&gt;
        h1{
            color: green;
        }

    &lt;/style&gt;
    &lt;!--外部样式--&gt;
    &lt;link rek=&quot;stylesheet&quot; href=&quot;css/style.css&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--优先级，就近原则--&gt;
&lt;!--行内样式：在标签元素中，编写一个Style属性，编写样式即可--&gt;
&lt;h1 style=&quot;color:red&quot;&gt;我是标题&lt;/h1&gt;


&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>拓展 ： 外部样式两种写法</p>
<ul>
<li>
<p>链接式</p>
<pre><code class="language-html">&lt;!--外部样式--&gt;
    &lt;link rek=&quot;stylesheet&quot; href=&quot;css/style.css&quot;&gt;
</code></pre>
</li>
<li>
<p>导入式-不推荐</p>
<p>css 2.1特有的</p>
</li>
</ul>
<pre><code class="language-html">&lt;!--导入式--&gt;
   &lt;style&gt;
       @import url(&quot;css/style.css&quot;);
   &lt;/style&gt;
</code></pre>
<blockquote>
<p>注意</p>
</blockquote>
<p>就结论而言，强烈建议使用<code>link</code>标签，慎用<code>@import</code>方式。<br>
这样可以避免考虑<code>@import</code>的语法规则和注意事项，避免产生资源文件下载顺序混乱和http请求过多的烦恼。</p>
<h4 id="区别">区别</h4>
<p><strong>1.从属关系区别</strong><br>
<code>@import</code>是 CSS 提供的语法规则，只有导入样式表的作用；<code>link</code>是HTML提供的标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性等。</p>
<p><strong>2.加载顺序区别</strong><br>
加载页面时，<code>link</code>标签引入的 CSS 被同时加载；<code>@import</code>引入的 CSS 将在页面加载完毕后被加载。</p>
<p><strong>3.兼容性区别</strong><br>
<code>@import</code>是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；<code>link</code>标签作为 HTML 元素，不存在兼容性问题。</p>
<p><strong>4.DOM可控性区别</strong><br>
可以通过 JS 操作 DOM ，插入<code>link</code>标签来改变样式；由于 DOM 方法是基于文档的，无法使用<code>@import</code>的方式插入样式。</p>
<p><strong>5.权重区别(该项有争议，下文将详解)</strong><br>
<code>link</code>引入的样式权重大于<code>@import</code>引入的样式。</p>
<h1 id="2选择器">2.选择器</h1>
<blockquote>
<p>作用：选择页面上的某一个或者某一类元素</p>
</blockquote>
<h2 id="21-基本选择器">2.1、基本选择器</h2>
<ol>
<li>
<p>标签选择器 ：选择一类标签 标签｛｝</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;style&gt;
        h1{
            color: green;
        }
        P{
            color: red;
        }
    &lt;/style&gt;

&lt;/head&gt;
&lt;body&gt;

&lt;h1&gt;hao&lt;/h1&gt;
&lt;p&gt;so&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
</li>
<li>
<p>类选择器 class：选中所有class属性一致的标签，跨标签 .类名｛｝</p>
<pre><code class="language-html">
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;style&gt;
    /*类选择器的格式 .class的名称｛｝
    好处，可以多个标签归类，是同一个class，可以复用

    */
    .hao{
        color: green;

    }
    .li{
        color: red;

    }

    &lt;/style&gt;

&lt;/head&gt;
&lt;body&gt;


&lt;h1 class=&quot;hao&quot;&gt;标题1&lt;/h1&gt;
&lt;h1 class=&quot;li&quot;&gt;标题2&lt;/h1&gt;
&lt;h1 class=&quot;hao&quot;&gt;标题3&lt;/h1&gt;
&lt;p class=&quot;hao&quot;&gt;p标签&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
</li>
<li>
<p>ID选择器：全局唯一 #id名{}</p>
<pre><code class="language-html">
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
   &lt;style&gt;
       /* id选择器 :id全局唯一
        #id名称{}
        不遵循就近原则，固定的
        id选择器&gt; class选择器&gt; 标签选择器
        */
       #hao{
           color: green;
       }
       .style1{
           color: red;
       }
   &lt;/style&gt;


&lt;/head&gt;
&lt;body&gt;
&lt;h1 id=&quot;hao&quot;&gt;标题1&lt;/h1&gt;
&lt;h1 class=&quot;style1&quot;&gt;标题2&lt;/h1&gt;
&lt;h1 class=&quot;style1&quot;&gt;标题3&lt;/h1&gt;
&lt;h1 id=&quot;liu&quot;&gt;标题4&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<blockquote>
<p>优先级 id选择器&gt; class选择器&gt; 标签选择器</p>
</blockquote>
</li>
</ol>
<h2 id="22-层次选择器">2.2、层次选择器</h2>
<ol>
<li>
<p>后代选择器 ：在某个元素的后面  祖爷爷  爷爷  爸爸 儿子</p>
<pre><code class="language-css">/*后代选择器*/
body p{
    background: red;
}
</code></pre>
</li>
<li>
<p>子选择器，一代 儿子</p>
<pre><code class="language-css">/*子选择器*/
body&gt;p{
    background: aqua;
}
</code></pre>
</li>
<li>
<p>相邻兄弟选择器 同辈</p>
<pre><code class="language-css">/*相邻兄弟选择器：只有一个，相邻（向下）*/
.active+p{
    background: blue;

}
</code></pre>
</li>
<li>
<p>通用选择器</p>
<pre><code class="language-css">/* 通用兄弟选择器，当前向下元素的所有兄弟*/
.active~p{
    background: brown;
}

</code></pre>
</li>
</ol>
<h2 id="23-结构伪类选择器">2.3、结构伪类选择器</h2>
<p>伪类： 条件</p>
<pre><code class="language-css">/*ul的第一个子元素*/

ul li:first-child{
  background: brown;
}

/*ul的最后一个子元素*/
ul li:last-child{
  background: brown;
}

/* 只选中p1：定位到父元素，选择当前的第一个元素
选择当前p元素的父级元素，选中父级元素的第一个，并且是当前元素才生效！*/
p:nth-child(1){
  background: green;
}

/*选中父元素下的p元素的第二个*/
p:nth-of-type(2){
  background: blue;
}

</code></pre>
<h2 id="24-属性选择器常用">2.4、属性选择器（常用）</h2>
<p>id + class 结合</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;

    &lt;style&gt;
      .demo a{
        float: left;
        display: block;
        height: 50px;
        width: 50px;
        border-radius: 10px;
        background: green;
        text-align: center;
        text-decoration: none;
        color: darkgray;
        margin-right:5px;
        font:bold 20px/50px Arial;
      }
      /*属性名，属性名 = 属性值（正则）
      = 绝对等于
      *= 包含这个元素
      ^=以这个开头
      $=以这个结尾
      */
      /*存在id属性的元素a[]{}*/

      /*id=firsr的元素*/
      /*a[id=first]{*/
      /*    background: yellow;*/

      /*}*/
      /*class中有links的元素 */
      /*a[class*=&quot;links&quot;]{*/
      /*    background: yellow;*/
      /*}*/

      /*选中href中以http开头的元素*/
      /*a[href^=http]{*/
      /*    background: yellow;*/
      /*}*/
      /*选中以$结尾的元素*/
      a[href$=pdf]{
        background: yellow;
      }


    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;

    &lt;p class=&quot;demo&quot;&gt;
      &lt;a href=&quot;http://www.baidu.com&quot; class=&quot;links item first&quot; id=&quot;first&quot;&gt;1&lt;/a&gt;
      &lt;a href=&quot;&quot; class=&quot;links item active&quot; target=&quot;_blank&quot;&gt;2&lt;/a&gt;
      &lt;a href=&quot;image/123.html&quot;class=&quot;links item&quot;&gt;3&lt;/a&gt;
      &lt;a href=&quot;image/123.png&quot; class=&quot;links item&quot;&gt;4&lt;/a&gt;
      &lt;a href=&quot;abc&quot; class=&quot;links item&quot;&gt;5&lt;/a&gt;
      &lt;a href=&quot;/a.pdf&quot; class=&quot;links item&quot;&gt;6&lt;/a&gt;
      &lt;a href=&quot;/abc.pdf&quot;class=&quot;links item&quot;&gt;7&lt;/a&gt;
      &lt;a href=&quot;abc.doc&quot; class=&quot;links item&quot;&gt;8&lt;/a&gt;
      &lt;a href=&quot;abcd.doc&quot; class=&quot;links item last&quot;&gt;9&lt;/a&gt;

    &lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;

</code></pre>
<figure data-type="image" tabindex="2"><img src="http://img.yanjiemao.top/image-20200821105658195.png" alt="image-20200821105658195" loading="lazy"></figure>
<pre><code>=
*=
^=
$=
</code></pre>
<h1 id="3美化网页元素">3.美化网页元素</h1>
<h2 id="31-为什么要美化网页">3.1、为什么要美化网页</h2>
<ol>
<li>有效传递页面信息</li>
<li>美化网页，页面漂亮，才能吸引用户</li>
<li>凸显页面主题</li>
<li>提高用户体验</li>
</ol>
<p>span便签: 重点要突出的字，使用span标签</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;style&gt;
      #title1{
        font-size: 50px;

      }
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;

    欢迎学习 &lt;span id=&quot;title1&quot;&gt;java&lt;/span&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="32-字体样式">3.2、字体样式</h2>
<pre><code class="language-html">&lt;!--
font-family:字体
font-size: 字体大小
font-weight:字体粗细
color :字体颜色

--&gt;
&lt;style&gt;

  body{
    font-family:&quot;Arial Black&quot; 楷体;
    color: brown;
  }
  h1{
    font-size: 50px;
  }
  .p1{
    font-weight: bold;
  }
&lt;/style&gt;
</code></pre>
<h2 id="33-文本样式">3.3、文本样式</h2>
<ol>
<li>颜色 color rgb rgba</li>
<li><strong>文本对齐方式  text-align = center</strong></li>
<li><strong>首行缩进 text-indent:2em</strong></li>
<li><strong>行高 line-height: 单行文字上下居中  line-height=height</strong></li>
<li>装饰  text-decoration</li>
<li>文本水平对齐：vertical-align:middle</li>
</ol>
<h2 id="34-阴影">3.4、阴影</h2>
<pre><code class="language-css">/*text-shadow:阴影颜色，水平偏移，垂直偏移，阴影半径*/
#price{
  text-shadow:#blue 10px -10px 2px;
}

</code></pre>
<h2 id="35-超链接伪类">3.5、超链接伪类</h2>
<p>正常情况下，a, a:hover</p>
<pre><code class="language-css">/*默认的颜色*/
a{
text-decoration: none;
color: blue;
}
/*鼠标悬浮的颜色只需要记住hover*/
a:hover{
color: yellow;
font-size: 50px;

}
/*鼠标按住未释放*/
a:active{
color: brown;
}
</code></pre>
<h2 id="36-列表">3.6、列表</h2>
<pre><code class="language-css">/*ul li*/
/*
list-style:
    none:去掉圆点
    circle：空心圆
    decimal:数字
    squar:正方形
*/

/*ul{*/
/*    background: gray;*/
/*}*/

ul li{
    height: 30px;
    list-style: none;
    text-indent: 1em;
}

</code></pre>
<h2 id="37-背景">3.7、背景</h2>
<p>背景颜色</p>
<p>背景图片</p>
<pre><code class="language-css">&lt;style&gt;
div{
  width: 500px;
  height: 300px;
  border:1px solid red;
  background-image:url(&quot;images/2.png&quot;) ;
}
.div1{
  background-repeat: repeat-x;
}

.div2{
  background-repeat: repeat-y;
}
.div3{
  background-repeat: no-repeat;
}
&lt;/style&gt;
</code></pre>
<h2 id="38-渐变">3.8、渐变</h2>
<pre><code class="language-css">background-color: #4158D0;
background-image: linear-gradient(43deg, #4158D0 0%, #C850C0 46%, #FFCC70 100%);

</code></pre>
<h1 id="4盒子模型">4.盒子模型</h1>
<h2 id="41-什么是盒子">4.1、什么是盒子</h2>
<figure data-type="image" tabindex="3"><img src="http://img.yanjiemao.top/image-20200822134547100.png" alt="image-20200822134547100" loading="lazy"></figure>
<p>margin:外边距</p>
<p>padding：内边距</p>
<p>border:边框</p>
<h2 id="42-边框">4.2、边框</h2>
<ol>
<li>边框的粗细</li>
<li>边框的样式</li>
<li>边框的颜色</li>
</ol>
<pre><code class="language-css">h1,ul,li,a,body{
  margin:0;
  padding:0;
  text-decoration: none;
}
#box{
  width: 300px;
  border:1px solid red;
}
h2{
  background: aqua;
  font-size: 16px;
  line-height: 30px;
  margin: 0;
}
form{
  background: #1dd2bd;
}
div:nth-of-type(2) input{
  border: 3px solid #56aa88;
}
</code></pre>
<h2 id="43-内外边距">4.3、内外边距</h2>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;!--
外边距的妙用：居中元素
margin:0
--&gt;
    &lt;style&gt;
      h1,ul,li,a,body{
        margin:0;
        padding:0;
        text-decoration: none;
      }
      #box{
        width: 300px;
        border:1px solid red;
      }
      /*顺时针旋转
      margin: 0 1px 2px 3px
      */

      h2{
        background: aqua;
        font-size: 16px;
        line-height: 30px;
        margin: 0;
      }
      form{
        background: #1dd2bd;
      }
      div:nth-of-type(2) input{
        border: 3px solid #56aa88;
        padding:10px;
      }

    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;

    &lt;div id=&quot;box&quot;&gt;
      &lt;h2&gt;会员登录&lt;/h2&gt;
      &lt;form action=&quot;#&quot;&gt;
        &lt;div&gt;
          &lt;span&gt;用户名:&lt;/span&gt;
          &lt;input type=&quot;text&quot;&gt;
        &lt;/div&gt;
        &lt;div&gt;
          &lt;span&gt;密码:&lt;/span&gt;
          &lt;input type=&quot;text&quot;&gt;
        &lt;/div&gt;
        &lt;div&gt;
          &lt;span&gt;邮箱:&lt;/span&gt;
          &lt;input type=&quot;text&quot;&gt;
        &lt;/div&gt;

      &lt;/form&gt;


    &lt;/div&gt;

  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>盒子的计算方式：你这个元素究竟有多大？</p>
<img src="http://img.yanjiemao.top/image-20200823095308419.png" alt="image-20200823095308419" style="zoom:80%;" />
<p>margin+border+padding+内容宽度</p>
<h2 id="44-圆角边框">4.4、圆角边框</h2>
<p>4个角</p>
<pre><code class="language-html">&lt;style&gt;
  div{
    width:100px;
    height: 100px;
    border:10px solid red;
    border-radius: 100px;
  }
&lt;/style&gt;
</code></pre>
<h2 id="45-盒子阴影">4.5、盒子阴影</h2>
<pre><code class="language-css">div{
  width:100px;
  height: 100px;
  border:10px solid red;
  border-radius: 60px;
  margin: 0 auto;
  box-shadow: 10px 10px 60px yellow;
}
</code></pre>
<h1 id="5浮动">5.浮动</h1>
<h2 id="51-标准文档流">5.1、标准文档流</h2>
<figure data-type="image" tabindex="4"><img src="http://img.yanjiemao.top/image-20200823105344842.png" alt="image-20200823105344842" loading="lazy"></figure>
<p>块级元素：独占一行</p>
<pre><code class="language-html">h1-h6 p div 列表···
</code></pre>
<p>行内元素：不独占一行</p>
<pre><code class="language-html">span a img strong···
</code></pre>
<p>行内元素可以被包含在块级元素中，反之不可以</p>
<h2 id="52-display">5.2、display</h2>
<pre><code class="language-css">
&lt;!--
block 块元素
inline 行内元素
inline-block 是块元素，但是可以内联，在一行
none 消失
--&gt;
&lt;style&gt;

div{
  width: 100px;
  height: 100px;
  border: 1px solid red;
  display: inline;
}
span{
  width: 100px;
  height: 100px;
  border: 1px solid red;
  display: inline-block;
}
&lt;/style&gt;
</code></pre>
<p>这个也是一种实现行内元素排列的方式，但是我们很多情况情况都是用float</p>
<h2 id="53-float">5.3、float</h2>
<p>1、左右浮动 float</p>
<pre><code class="language-css">div{
  margin:10px;
  padding:10px;
}
.layer1{
  float:right;
}

.layer2{
  float:left;
}
</code></pre>
<h2 id="54-父级边框塌陷的问题">5.4 、父级边框塌陷的问题</h2>
<blockquote>
<p>解决方案</p>
</blockquote>
<p>1.增加父级元素的高度</p>
<pre><code class="language-CSS">#father{
  border:1px #000 solid;
  height: 800px;
}
</code></pre>
<p>2.增加一个空的div标签，清除浮动</p>
<pre><code class="language-css">&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;
.clear{
  clear: both;
  margin: 0;
  padding: 0;
}
</code></pre>
<p>3.overflow</p>
<pre><code class="language-css">在父级元素中增加一个 overflow：hidden;
</code></pre>
<p>4、父类增加一个伪类</p>
<pre><code class="language-css">#father:after{
  content: '';
  dispaly: block;
  clear:both;
}
</code></pre>
<p>小结：</p>
<ol>
<li>浮动元素后面增加空div</li>
</ol>
<ul>
<li>简单，代码中尽量避免空div</li>
</ul>
<ol start="2">
<li>
<p>设置父元素高度</p>
<p>简单，元素假设有了固定的高度，就会被限制</p>
</li>
<li>
<p>overflow</p>
<p>简单，下拉的一些场景，避免使用</p>
</li>
<li>
<p>父类添加一个伪类：after(<strong>推荐</strong>)</p>
</li>
</ol>
<h2 id="55-对比">5.5、对比</h2>
<ul>
<li>
<p>display</p>
<p>方向不可以控制</p>
</li>
<li>
<p>float</p>
<p>浮动起来的话会脱离标准文档流，所以要解决父级边框塌陷的问题</p>
</li>
</ul>
<h1 id="6定位">6.定位</h1>
<h2 id="61-相对定位">6.1、相对定位</h2>
<pre><code class="language-css">
&lt;!--相对定位
相对于自己原来的位置进行偏移
--&gt;
&lt;style&gt;
body{
  padding: 20px;
}
div{
  margin: 10px;
  padding: 5px;
  font-size: 12px;
  line-height: 25px;
}
#father{
  border: 1px solid red;
}
#first{
  background: green;
  border: 1px dashed blue;
  position: relative; /*相对定位*/
  top: -20px;
  left: 20px
}
#second{
  background: aqua;
  border: 1px dashed blue;
}
#third{
  background: green;
  border: 1px dashed blue;
  position: relative;
  bottom: 10px;
  right: 20px;
}
&lt;/style&gt;
</code></pre>
<p>相对定位：positionl: relative;</p>
<p>相对于原来的位置，进行指定的偏移,相对定位仍然在标准文档流中，原来的位置会被保留</p>
<pre><code>top: -20px;
left: 20px;
bottom: -10px;
right: 20px;
</code></pre>
<h2 id="62-绝对定位">6.2、绝对定位</h2>
<p>定位：基于xxx定位，上下左右</p>
<ol>
<li>没有父级元素定位的前提下，相对于浏览器定位</li>
<li>假设父级元素存在定位，我们通常会相对于父级元素进行偏移</li>
<li>在父级元素范围内移动，相对于父级或浏览器的位置，进行指定的偏移，绝对定位的话，它不在标准文档流中，原来的位置不会被保留。</li>
</ol>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;

    
    &lt;style&gt;
        body{
            padding: 20px;
        }
        div{
            margin: 10px;
            padding: 5px;
            font-size: 12px;
            line-height: 25px;
        }
        #father{
            border: 1px solid red;
        }
        #first{
            background: green;
            border: 1px dashed blue;

        }
        #second{
            background: aqua;
            border: 1px dashed blue;
            position: absolute;
            right: 30px;
        }
        #third{
            background: green;
            border: 1px dashed blue;

        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div id=&quot;father&quot;&gt;
    &lt;div id=&quot;first&quot;&gt;1&lt;/div&gt;
    &lt;div id=&quot;second&quot;&gt;2&lt;/div&gt;
    &lt;div id=&quot;third&quot;&gt;3&lt;/div&gt;
&lt;/div&gt;

&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<h2 id="63-固定定位">6.3、固定定位</h2>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;

    &lt;style&gt;
      body{
        height: 1000px;

      }
      div:nth-of-type(1){  /*绝对定位：相对于浏览器*/
        width:100px;
        height: 100px;
        background: green;
        position: absolute;
        right: 0;
        bottom: 0;

      }

      div:nth-of-type(2){/*fixed,固定定位*/
        width:50px;
        height: 50px;
        background: yellow;
        position: fixed;
        right: 0;
        bottom: 0;

      }
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;

    &lt;div&gt;div1&lt;/div&gt;
    &lt;div&gt;div2&lt;/div&gt;

  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="64-z-index">6.4、z-index</h2>
<img src="http://img.yanjiemao.top/image-20200823193345111.png" alt="image-20200823193345111" style="zoom: 67%;" />
<p>图层~</p>
<p>z-index默认为0，最高999</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot;&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div id=&quot;content&quot;&gt;
    &lt;ul&gt;
        &lt;li&gt;&lt;img src=&quot;images/1.jpg&quot; alt=&quot;&quot; &lt;/li&gt;
        &lt;li class=&quot;tipText&quot;&gt;冷兔宝宝&lt;/li&gt;
        &lt;li class=&quot;tipBg&quot;&gt;&lt;/li&gt;
        &lt;li&gt;时间： 2020-01-01&lt;/li&gt;
        &lt;li&gt;地点；天津&lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>opacity: 0.1; /<em>背景透明度</em>/</p>
<pre><code class="language-css">#content{
  width: 350px;
  padding:0px;
  margin: 0px;
  overflow: hidden;
  font-size: 12px;
  line-height:25px;
  border: 1px solid red;

}

ui,li{
  padding: 0px;
  margin: 0px;
  list-style: none;
}

/*父级元素相对定位*/

#content ul{
  position: relative;
}

.tipText, .tipBg{
  position: absolute;
  width: 380px;
  height: 25px;
  top: 220px;
}
.tipText{
  color: green;
  /*z-index: 0;*/
}
.tipBg{
  background: black;
  opacity: 0.1; /*背景透明度*/
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HTML5]]></title>
        <id>https://www.jianso.tech/lab/post/HTML5/</id>
        <link href="https://www.jianso.tech/lab/post/HTML5/">
        </link>
        <updated>2020-08-04T16:00:00.000Z</updated>
        <content type="html"><![CDATA[<h1 id="html5">HTML5</h1>
<h2 id="1网页基本信息">1.网页基本信息</h2>
<p>html基本结构</p>
<p>DOCTTYPE声明</p>
<p>标签</p>
<blockquote>
<p>第一个网页</p>
</blockquote>
<pre><code class="language-html">
&lt;!DOCTYPE html&gt;
&lt;!--DOCTYPE 告诉浏览器,我们使用什么规范--&gt;
&lt;html lang=&quot;en&quot;&gt;

&lt;!--head 代表网页的头部  --&gt;
&lt;head&gt;
	&lt;!-- meta描述性标签,用来描述网站的一些信息 --&gt;
	&lt;!-- 一般用来做seo --&gt;
	&lt;meta charset=&quot;utf-8&quot;&gt;
	&lt;meta name=&quot;keywords&quot; content=&quot;眼睫毛的网站&quot;&gt;
	&lt;meta name=&quot;description&quot; content=&quot;来这里可以学习计算机&quot;&gt;
	
	&lt;!-- 网页的标题 --&gt;
	&lt;title&gt;第一个网页&lt;/title&gt;
&lt;/head&gt;

&lt;!-- body表示网页的主体 --&gt;
&lt;body&gt;
若无闲事挂心头,便是人间好时节. 
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="2基本标签学习">2.基本标签学习</h2>
<ul>
<li>标题标签</li>
<li>段落标签</li>
<li>换行标签</li>
<li>水平线标签</li>
<li>字体样式标签</li>
<li>注释和特殊符号</li>
</ul>
<pre><code class="language-html">
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;!-- 标题标签 --&gt;
&lt;h1&gt;一级标签&lt;/h1&gt;
&lt;h2&gt;二级标签&lt;/h2&gt;
&lt;h3&gt;三级标签&lt;/h3&gt;
&lt;h4&gt;四级标签&lt;/h4&gt;
&lt;h5&gt;五级标签&lt;/h5&gt;
&lt;h6&gt;六级标签&lt;/h6&gt;

&lt;!-- 段落标签 --&gt;
&lt;p&gt;客路青山外，行舟绿水前。&lt;/p&gt;
&lt;p&gt;潮平两岸阔，风正一帆悬。&lt;/p&gt;

&lt;!-- 水平线标签 --&gt;
&lt;hr/&gt;

&lt;!-- 换行标签 --&gt;
客路青山外，行舟绿水前。
&lt;br/&gt;
潮平两岸阔，风正一帆悬。

&lt;!-- 粗体,斜体标签 --&gt;
&lt;h1&gt;字体样式标签&lt;/h1&gt;
粗体:&lt;strong&gt;啦啦啦啦啦&lt;/strong&gt;
斜体:&lt;em&gt;啦啦啦啦啦&lt;/em&gt;
&lt;br/&gt;
&lt;!-- 特殊符号 --&gt;
&amp;nbsp;空格
&lt;br/&gt;
&amp;gt;大于
&lt;br/&gt;
&amp;lt;小于
&lt;br/&gt;
&amp;copy;版权符号

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="3图像标签">3.图像标签</h2>
<pre><code class="language-html">
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;

&lt;head&gt;
	&lt;meta charset=&quot;utf-8&quot;&gt;
	&lt;title&gt;图像标签&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!-- img 
  相对地址 绝对地址
  ../ 上一级目录
  alt:图片名字(必填)
--&gt;
&lt;img src=&quot;img/1.jpg&quot;alt=&quot;一二&quot; title=&quot;悬停文字&quot; width=&quot;300&quot; height=&quot;300&quot;&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="4超链接标签及应用">4.超链接标签及应用</h2>
<p>页面间链接</p>
<pre><code class="language-html">

&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;

&lt;head&gt;
	&lt;meta charset=&quot;utf-8&quot;&gt;
	&lt;title&gt;连接标签&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;!--a标签
 href: 一定得有,表示跳转到哪里
 target: 表示新标签在哪里打开
		_blank 在新窗口打开
		_self 在原来的窗口打开,默认self

--&gt;

&lt;a href=&quot;http://www.baidu.com&quot; target=&quot;_blank&quot;&gt;点击跳转百度&lt;/a&gt;
&lt;br&gt;
&lt;a href=&quot;http://www.baidu.com&quot;&gt;点击跳转百度&lt;/a&gt;
&lt;br&gt;
&lt;a href=&quot;http://www.baidu.com&quot;&gt;
&lt;img src=&quot;img/1.jpg&quot;alt=&quot;一二&quot; title=&quot;悬停文字&quot; width=&quot;300&quot; height=&quot;300&quot;&gt;
&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;


</code></pre>
<p>锚链接</p>
<pre><code class="language-html">&lt;!-- 锚链接
1.需要一个锚标记
2.跳转到标记
 --&gt; 

&lt;a href=&quot;#top&quot;&gt;回到顶部&lt;/&gt;
&lt;a href=&quot;http://news.baidu.com#footer&quot;&gt;点击跳转百度&lt;/a&gt;
</code></pre>
<p>功能性链接</p>
<pre><code class="language-html">&lt;!-- 功能性链接
  邮件链接:mailto:
  qq链接

--&gt;
&lt;a href=&quot;mailto:1447748014@qq.com&quot;&gt;邮箱联系我&lt;/&gt;
&lt;a target=&quot;_blank&quot; href=&quot;http://wpa.qq.com/msgrd?v=3&amp;uin=&amp;site=qq&amp;menu=yes&quot;&gt;
&lt;img border=&quot;0&quot; src=&quot;http://wpa.qq.com/pa?p=2::53&quot; 
alt=&quot;点击这里给我发消息&quot; title=&quot;点击这里给我发消息&quot;/&gt;&lt;/a&gt;

</code></pre>
<h2 id="5行内元素和块元素">5.行内元素和块元素</h2>
<p>块元素:</p>
<ul>
<li>无论内容多少,该元素独占一行</li>
<li>(p,h1-h6....)</li>
</ul>
<p>行内元素</p>
<ul>
<li>内容撑开宽度,左右都是行内元素的可以排在一行</li>
<li>&lt;a .strong . em ....)</li>
</ul>
<h2 id="6列表标签">6.列表标签</h2>
<pre><code class="language-html">
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;

&lt;head&gt;
	&lt;meta charset=&quot;utf-8&quot;&gt;
	&lt;title&gt;列表标签&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;

&lt;!--有序列表--&gt;

&lt;ol&gt;
	&lt;li&gt;java&lt;/li&gt;
	&lt;li&gt;c&lt;/li&gt;
	&lt;li&gt;前端&lt;/li&gt;
&lt;/ol&gt;

&lt;!--无序列表--&gt;

&lt;ul&gt;
	&lt;li&gt;java&lt;/li&gt;
	&lt;li&gt;c&lt;/li&gt;
	&lt;li&gt;前端&lt;/li&gt;
	
&lt;/ul&gt;

&lt;!--自定义列表--&gt;
&lt;dl&gt;
	&lt;dt&gt;科目&lt;/dt&gt;
	&lt;dd&gt;语文&lt;/dd&gt;
	&lt;dd&gt;数学&lt;/dd&gt;
	&lt;dd&gt;英语&lt;/dd&gt;
	&lt;dd&gt;理综&lt;/dd&gt;

&lt;/dl&gt;
	
	

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="7媒体元素">7.媒体元素</h2>
<pre><code class="language-html">
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;

&lt;head&gt;
	&lt;meta charset=&quot;utf-8&quot;&gt;
	&lt;title&gt;媒体元素&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;

&lt;!-- 音频和视频
src:资源目录
controls:进度条
autoplay :自动播放
--&gt;
&lt;video src=&quot;./img/1.mp4&quot; controls autoplay&gt; &lt;/video&gt;
&lt;br&gt;
&lt;audio src=&quot;./img/2.mp3&quot; controls autoplay&gt; &lt;/audio&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="8iframe内嵌框架">8.iframe内嵌框架</h2>
<pre><code class="language-html">
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;

&lt;head&gt;
	&lt;meta charset=&quot;utf-8&quot;&gt;
	&lt;title&gt;iframe &lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;!-- iframe 内联框架
src:地址
--&gt;
&lt;iframe name=&quot;hello&quot; src=&quot;http://www.baidu.com&quot; frameborder=&quot;0&quot; width=800&quot; height=&quot;800&quot;&gt;&lt;/iframe&gt;
&lt;a href=&quot;http://news.baidu.com&quot; target=&quot;hello&quot;&gt;点击跳转&lt;/a&gt;


&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="9表单post和get提交">9.表单post和get提交</h2>
<pre><code class="language-html">
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;

&lt;head&gt;
	&lt;meta charset=&quot;utf-8&quot;&gt;
	&lt;title&gt;post-get&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;!--表单form
action : 表单提交的位置,可以是网站也可以是一个请求处理地址,向何处提交表单数据
method :post get 提交方式
      get方式提交:可以在url中看到提交的信息,不安全,搞笑
	  post:看不到安全,可以传输大文件
--&gt;

&lt;form action=&quot;1.html&quot; method=&quot;get&quot;&gt;
	&lt;p&gt;名字:&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;/p&gt;
	&lt;p&gt;密码:&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;/p&gt;
	&lt;p&gt; 
		&lt;input type=&quot;submit&quot;&gt;
		&lt;input type=&quot;reset&quot;&gt;
	&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="10表单元素">10.表单元素</h2>
<figure data-type="image" tabindex="1"><img src="http://img.yanjiemao.top/image-20200730165959793.png" alt="image-20200730165959793" loading="lazy"></figure>
<pre><code class="language-html">

&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;

&lt;head&gt;
	&lt;meta charset=&quot;utf-8&quot;&gt;
	&lt;title&gt;post-get&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;!--表单form
action : 表单提交的位置,可以是网站也可以是一个请求处理地址,向何处提交表单数据
method :post get 提交方式
      get方式提交:可以在url中看到提交的信息,不安全,搞笑
	  post:看不到安全,可以传输大文件
--&gt;

&lt;form action=&quot;1.html&quot; method=&quot;get&quot;&gt;
	&lt;p&gt;名字:&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;/p&gt;
	&lt;p&gt;密码:&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;/p&gt;
	
	
&lt;!-- 单选框标签
 input type=&quot;radio&quot;
 value:单选框的值
 name:表示组
 --&gt;
&lt;p&gt;性别:
	&lt;input type=&quot;radio&quot; value=&quot;boy&quot; name=&quot;sex&quot;/&gt;男
	&lt;input type=&quot;radio&quot; value=&quot;girl&quot; name=&quot;sex&quot;/&gt;女
&lt;/p&gt;
 
&lt;!-- 多选框
 input type=&quot;checkbox&quot;
  --&gt;
&lt;p&gt;爱好:
	&lt;input type=&quot;checkbox&quot; value=&quot;sleep&quot; name=&quot;hobby&quot;&gt;睡觉
	&lt;input type=&quot;checkbox&quot; value=&quot;code&quot; name=&quot;hobby&quot;&gt;写代码
	&lt;input type=&quot;checkbox&quot; value=&quot;chat&quot; name=&quot;hobby&quot;&gt;聊天
	&lt;input type=&quot;checkbox&quot; value=&quot;tv&quot; name=&quot;hobby&quot;&gt;看电视
&lt;/p&gt;
&lt;!-- 按钮 
input type=&quot;button&quot; 普通按钮 
input type=&quot;image&quot;  图像按钮,也可以提交
input type=&quot;submit&quot;  提交按钮
input type=&quot;reset&quot;   重置按钮
--&gt;

&lt;p&gt;按钮:
	&lt;input type=&quot;button&quot; name=&quot;btn1&quot; value=&quot;点我&quot;&gt;
	图片按钮:
	&lt;input type=&quot;image&quot; src=&quot;./img/1.jpg&quot; width=&quot;25px&quot; heigh=&quot;25px&quot;&gt;
&lt;/p&gt;



&lt;!-- 下拉框,列表框 

--&gt;
&lt;p&gt;国家:
	&lt;select name=&quot;列表名称&quot;&gt;
		&lt;option value=&quot;china&quot;&gt;中国&lt;/option&gt;
		&lt;option value=&quot;usa&quot;&gt;美国&lt;/option&gt;
		&lt;option value=&quot;japan&quot;&gt;日本&lt;/option&gt;
		&lt;option value=&quot;korea&quot;&gt;韩国&lt;/option&gt;
	&lt;/select&gt;
&lt;/P&gt;

&lt;!-- 文本域
 cols=&quot;50&quot; rows=&quot;10&quot;
 --&gt;
 
&lt;p&gt;反馈:
	&lt;textarea name=&quot;textarea&quot; cols=&quot;50&quot; rows=&quot;10&quot;&gt;啦啦啦&lt;/textarea&gt;
&lt;/p&gt;

&lt;!-- 文件域
input type=&quot;file&quot;
 --&gt;
&lt;p&gt;
	&lt;input type=&quot;file&quot; name=&quot;files&quot;&gt;
	&lt;input type=&quot;button&quot; value=&quot;上传&quot; name=&quot;upload&quot;&gt;
&lt;/p&gt;


&lt;!-- 邮件验证 --&gt;

&lt;p&gt; 邮箱:
	&lt;input type=&quot;email&quot; name=&quot;email&quot;&gt;
&lt;/P&gt;

&lt;!-- url --&gt;

&lt;p&gt; URl :
	&lt;input type=&quot;url&quot; name=&quot;url&quot;&gt;
&lt;/P&gt;

&lt;!-- 数字 --&gt;
 
&lt;p&gt; 数字:
	&lt;input type=&quot;number&quot; name=&quot;num&quot; max=&quot;100&quot; min=&quot;10&quot; step=&quot;10&quot;&gt;
&lt;/P&gt;

&lt;!-- 滑块 --&gt;

&lt;p&gt;音量:
	&lt;input type=&quot;range&quot; name=&quot;voice&quot; min=&quot;0&quot; max=&quot;100&quot; step=&quot;5&quot;&gt;
&lt;/p&gt;

&lt;!-- 搜索框 --&gt;
&lt;p&gt;搜索:
	&lt;input type=&quot;search&quot; name=&quot;search&quot;&gt;
&lt;/p&gt;

&lt;p&gt; 
	&lt;input type=&quot;submit&quot;&gt;
	&lt;input type=&quot;reset&quot;&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="11表单简单应用">11.表单简单应用</h2>
<p>隐藏域 hidden</p>
<p>只读   readonly</p>
<p>禁用  disabled</p>
<p><strong>表单初级验证</strong></p>
<ul>
<li>placeholder  提示信息</li>
<li>require      非空判断</li>
<li>pattern    正则表达式</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript]]></title>
        <id>https://www.jianso.tech/lab/post/JavaScript/</id>
        <link href="https://www.jianso.tech/lab/post/JavaScript/">
        </link>
        <updated>2020-08-04T16:00:00.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1什么是javascript">1.什么是JavaScript</h2>
<h3 id="11-概述">1.1、概述</h3>
<p>JavaScript是世界上最流行的一门脚本语言</p>
<p>` 一个合格的后端人员，必须要精通JavaScri</p>
<h3 id="12-历史">1.2、历史</h3>
<p>历史</p>
<p><a href="https://blog.csdn.net/kese7952/article/details/79357868">https://blog.csdn.net/kese7952/article/details/79357868</a></p>
<p><strong>ECMAScript</strong>可以理解为是JavaScript的一个标准</p>
<p>最新版本es6</p>
<p>但大部分浏览器还是支持es5</p>
<h2 id="2快速入门">2.快速入门</h2>
<h3 id="21-引入javascript">2.1、引入JavaScript</h3>
<p>1.内部标签</p>
<pre><code class="language-html">&lt;script&gt;
  //....
&lt;/script&gt;
</code></pre>
<p>2.外部引入</p>
<p>abs.js</p>
<pre><code class="language-javascript">//....

</code></pre>
<p>test.html</p>
<pre><code class="language-html">&lt;script src=&quot;abc.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>第一个JavaScript弹窗</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;!--script标签内，写js代码--&gt;
&lt;!--    &lt;script&gt;--&gt;
&lt;!--        alert('你好，世界')--&gt;
&lt;!--    &lt;/script&gt;--&gt;
&lt;!--外部引入--&gt;
&lt;!--注意：script标签成对出现--&gt;
    &lt;script src=&quot;js/first.js&quot;&gt;&lt;/script&gt;

&lt;!--不用显示定义--&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;


&lt;!--这里也可以存放js代码--&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="22-基本语法入门">2.2、基本语法入门</h3>
<pre><code class="language-html">&lt;!--    JavaScript严格区分大小写--&gt;
    &lt;script&gt;
        // 1.定义变量
        var score= 75;
        //alert(num);
        // 2.条件控制
        if(score&gt;60 &amp;&amp; score&lt;70){
            alert(&quot;60-70&quot;);
        }else if(score&gt;70 &amp;&amp; score&lt;80){
            alert(&quot;70-80&quot;);
        }else{
            alert(&quot;other&quot;);
        }

        //console.log(score)在浏览器的控制台打印变量


    &lt;/script&gt;
</code></pre>
<p>浏览器调试</p>
<figure data-type="image" tabindex="1"><img src="http://img.yanjiemao.top/image-20200824110347114.png" alt="image-20200824110347114" loading="lazy"></figure>
<h3 id="23-数据类型">2.3、数据类型</h3>
<p>数值，文本，图形，音频，视频、、、</p>
<p><mark>变量</mark></p>
<pre><code class="language-js">var a = 1
</code></pre>
<p><mark>number</mark></p>
<p>js不区分小数和整数</p>
<pre><code class="language-js">123 //整数123
123.1 //浮点数123.1
1.23e4 //科学计数法
-99 //负数
NaN //not a number
Infinity //表示无限大
</code></pre>
<p><mark>字符串</mark></p>
<p>'abc',&quot;abc&quot;</p>
<p><mark>布尔值</mark></p>
<p>true false</p>
<p><mark>逻辑运算</mark></p>
<pre><code>&amp;&amp; 两个都为真，结果为真

|| 一个为真，结果为真

！ 真即假，假即真
</code></pre>
<p><mark>比较运算符</mark></p>
<pre><code>=

== 等于（类型不一样，值一样，也会判断为true）

=== 绝对等于（类型一样，值一样，结果为true）
</code></pre>
<p>这是js的缺陷，不要用==比较</p>
<blockquote>
<p>注意：</p>
<p>NaN===NaN,这个与所有的数值都不相等，包括自己</p>
<p>只能通过isNan(NaN)来判断是否是NaN</p>
</blockquote>
<p>浮点数问题</p>
<pre><code class="language-js"> console.log((1/3) === (1-2/3));
</code></pre>
<p>尽量避免使用浮点数进行运算，存在精度问题</p>
<pre><code class="language-html">console.log(Math.abs(1/3-(1-2/3))&lt;0.00000001)
</code></pre>
<p><mark>null和underfine</mark></p>
<ul>
<li>null 空</li>
<li>undefined未定义</li>
</ul>
<p><mark>数组</mark></p>
<p>Java的数值必须是一系列相同类型的对象,js不需要</p>
<pre><code class="language-js">//保证代码可读性，尽量使用[]
var arr = [1,2,3,4,5,'helo',null,true];
new Array(1,2,4,5,'kkk');
</code></pre>
<p>取数组下标，如果越界了，就会undefined</p>
<p><mark>对象</mark></p>
<p>对象是大括号，数组是中括号</p>
<p>每个属性之间用逗号隔开，最后一个不需要</p>
<pre><code class="language-js">//Person person = new Person(1,2,3,4,5)
var person = {
  name: &quot;haodapang&quot;,
  age: 3,
  tags: ['js','java','web','...']
}
</code></pre>
<p>取对象的值</p>
<pre><code class="language-js">person.age
&gt;3
person.tags
&gt;(4) [&quot;js&quot;, &quot;java&quot;, &quot;web&quot;, &quot;...&quot;]
</code></pre>
<h3 id="24-严格检查模式">2.4、严格检查模式</h3>
<pre><code class="language-html">
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;

&lt;!--
'use strict'严格检查模式，预防JavaScript的随意性导致产生以下问题
局部变量都建议使用let定义
'use strict' 必须写在JavaScript的第一行
--&gt;
    &lt;script&gt;
      'use strict'
      //全局变量
      let i = 1;
      // es6 中 let
    &lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;

  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="3数据类型">3.数据类型</h2>
<h3 id="31-字符串">3.1、字符串</h3>
<ol>
<li>
<p>正常字符串使用 <strong>单引号</strong> 或者 <strong>双引号</strong> 包裹</p>
</li>
<li>
<p>注意转义字符</p>
<pre><code class="language-bash">\'
\n
\t
\u42ed \u#### Unicode字符
\x41 Ascll字符
</code></pre>
</li>
<li>
<p>多行字符编写</p>
<pre><code class="language-javascript">//反引号`
var msg =
    `hello
world
你好`
</code></pre>
</li>
<li>
<p>模板字符串</p>
<pre><code class="language-js">
let name = &quot;haodapang&quot;;
let age = &quot;18&quot;;
let msg = `你好呀，${name}`
</code></pre>
</li>
<li>
<p>字符串长度</p>
<pre><code class="language-javascript">str.length
</code></pre>
</li>
<li>
<p>字符串的可变性，不可变</p>
<img src="http://img.yanjiemao.top/image-20200902174718407.png" alt="image-20200902174718407" style="zoom: 80%;" />
</li>
<li>
<p>大小写转换</p>
<pre><code class="language-js">//注意这里是方法不是属性
student.toUpperCase()
student.toLowerCase()
</code></pre>
</li>
<li>
<p>student.indexOf('t')</p>
</li>
<li>
<p>substring</p>
<pre><code class="language-js">student.substring(1)//从数组第一个字符串截取到最后一个字符
student.substring(1,3) //[1,3)
</code></pre>
</li>
</ol>
<h3 id="32-数组">3.2、数组</h3>
<p>Array可以包含任意的数据类型</p>
<pre><code class="language-js">var arr = [1,2,3,4,5,6]
</code></pre>
<p>1、 长度</p>
<pre><code>arr.length
</code></pre>
<p>注意: 假如给arr.length赋值，数组大小就会放生变化，如果赋值过小，元素就会丢失。</p>
<p>2、indexOf,通过元素获得下表索引</p>
<pre><code>arr.indexOf(2)
1
</code></pre>
<p>字符串的 &quot;1&quot; 和数字 1 不一样</p>
<img src="http://img.yanjiemao.top/image-20200903103650063.png" alt="image-20200903103650063" style="zoom:67%;" />
<p>3、slice（） 截取Array 的一部分，返回一个新数组，类似于string中的substring</p>
<p>4、push() pop ()</p>
<pre><code>push 压入到尾部
pop 弹出尾部一个元素
</code></pre>
<p>5、unshift() shift() 头部</p>
<pre><code>unshift 压入到头部
shift 弹出头部的一个元素
</code></pre>
<p>6、 排序 sort()</p>
<pre><code class="language-js">arr
(7) [8, 1, 2, 3, 4, &quot;1&quot;, &quot;2&quot;]
arr.sort()
(7) [1, &quot;1&quot;, 2, &quot;2&quot;, 3, 4, 8]
</code></pre>
<p>7、 元素反转reverse()</p>
<pre><code class="language-js">arr
(7) [1, &quot;1&quot;, 2, &quot;2&quot;, 3, 4, 8]
arr.reverse()
(7) [8, 4, 3, &quot;2&quot;, 2, &quot;1&quot;, 1]
</code></pre>
<p>8、concat()</p>
<pre><code class="language-js">arr
(7) [1, &quot;1&quot;, 2, &quot;2&quot;, 3, 4, 8]
arr.concat([6,6,6])
(10) [8, 4, 3, &quot;2&quot;, 2, &quot;1&quot;, 1, 6, 6, 6]
</code></pre>
<p>注意：这个方法并没有修改数组，只是会返回一个新的数组。</p>
<p>9、连接符join</p>
<p>打印拼接数组，使用特定的字符串连接</p>
<pre><code class="language-js">arr
(7) [8, 4, 3, &quot;2&quot;, 2, &quot;1&quot;, 1]
arr.join('-')
&quot;8-4-3-2-2-1-1&quot;
</code></pre>
<p>10、多维数组</p>
<pre><code class="language-js">arr = [[1,2],[3,4],[5,6]]
arr[1][1]
4
</code></pre>
<p>数组： 数据存储（如何存，如何取，方法都可以自己实现）</p>
<h3 id="33-对象">3.3、对象</h3>
<p>若干个键值对</p>
<pre><code class="language-js">var 对象名 = {
  属性名： 属性值，
  属性名： 属性值，
  属性名： 属性值         
 }

var person = {
  name: &quot;hao&quot;,
  age: 18,
  sex: &quot;boy&quot;

}
</code></pre>
<p>js中的对象，｛.....｝表示一个对象，键值对描述属性，xxx:xxx ,多个属性使用逗号隔开，<strong>最后一个属性不加逗号！</strong></p>
<p>js中的所有键都是字符串，值是任意对象！</p>
<p>1、对象赋值</p>
<pre><code class="language-js">person.name
&quot;hao&quot;
person.name = &quot;haodapang&quot;
&quot;haodapang&quot;
</code></pre>
<p>2、使用一个不存在的对象属性，不会报错！ undefined</p>
<pre><code class="language-js">person.haha
undefined
</code></pre>
<p>3、动态删减属性,通过delete删除属性</p>
<pre><code class="language-js">delete person.name
true
</code></pre>
<p>4、动态添加属性，直接给新的属性添加值即可</p>
<pre><code class="language-js">person.hah = &quot;haha&quot;
&quot;haha&quot;
</code></pre>
<p>5、判断属性值是否在这个对象中@！xxx in xxx!</p>
<pre><code class="language-js">'age' in person
true
//继承
'toString' in person
true
</code></pre>
<p>6、判断一个属性是否是这个对象自身拥有的hasOwnProperty()</p>
<pre><code class="language-js">person.hasOwnProperty('toString')
false
person.hasOwnProperty('age')
true
</code></pre>
<h3 id="34-流程控制">3.4、流程控制</h3>
<p>if判断</p>
<pre><code class="language-js">var age = 3;
if(age &gt; 3){
  alert(&quot;hahaha&quot;);

} else{
  alert(&quot;wawa&quot;);
}

</code></pre>
<p>while循环,避免程序死循环</p>
<pre><code class="language-js">while(age &lt; 100){
  age = age + 1;
  console.log(age);
}

do{
  age = age + 1;
  console.log(age);
}while(age &lt; 100)
</code></pre>
<p>for循环</p>
<pre><code class="language-js"> for (let i = 0; i &lt; 100; i++){
            console.log(i);
 }
</code></pre>
<p>forEach循环 5.1引入</p>
<pre><code class="language-js">var age = [1,2,34,45,65,76,33,44];

age.forEach(function(value){
  console.log(value)
})

</code></pre>
<p>for..in</p>
<pre><code class="language-js">var age = [1,2,34,45,65,76,33,44];

for(var num in age){

  console.log(age[num]);
}

</code></pre>
<p>for ...of</p>
<pre><code class="language-js">var age = [1,2,34,45,65,76,33,44];

for(var num of age){

  console.log(num);
}
</code></pre>
<h3 id="35-map和set">3.5、Map和Set</h3>
<p>Map</p>
<pre><code class="language-js">//学生的成绩，学生的名字
// var names = [&quot;tom&quot;,&quot;jack&quot;,&quot;lucy&quot;];
// var scores = [100,90,80]
var map = new Map([['tom',100],['jack',90],['lisa',85]]);
var name = map.get('tom');//通过key获取value
map.set('liu',99);//新增修改
map.delete(&quot;tom&quot;);//删除
</code></pre>
<p>Set:无序不重复的集合</p>
<pre><code class="language-js">var set = new Set([2,3,3,3]);//set可以去重
set.add(1);//添加
set.delete(3);//删除
console.log(set.has(1));//是否包含某个元素
</code></pre>
<h3 id="36-iterator">3.6、iterator</h3>
<blockquote>
<p>es6新特性</p>
</blockquote>
<p>使用iterator来便利迭代Map,Set!</p>
<pre><code class="language-js">//通过for of 实现 / for in 下标
var arr = [3,4,5];
for (var x of arr){
  console.log(x);
}
</code></pre>
<p>遍历map</p>
<pre><code class="language-js">var map = new Map([['tom',100],['lisa',89],['wang',88]]);
for(let x of map){
  console.log(x);
}
</code></pre>
<p>遍历set</p>
<pre><code class="language-js">var set = new Set([5,6,7]);
for(let x of set){
  console.log(x);
}
</code></pre>
<h2 id="4函数">4.函数</h2>
<h3 id="41-定义函数">4.1、定义函数</h3>
<blockquote>
<p>定义方式一</p>
</blockquote>
<pre><code class="language-js">function abs(x){
  if(x &gt;= 0){
    return x;
  }else {
    return -x;
  }
}
</code></pre>
<p>一旦执行到return代表函数结束，返回结果。</p>
<p>如果没有执行return，函数执行也会返回结果，结果就是underfined</p>
<blockquote>
<p>定义方式二</p>
</blockquote>
<pre><code class="language-js">var abs = function(x){
  if(x &gt;= 0){
    return x;
  }else {
    return -x;
  }
  
}
</code></pre>
<p>function(x).... 这是一个匿名函数，但是可以把结果复制给abs，通过abs就可以调用函数！</p>
<blockquote>
<p>调用函数</p>
</blockquote>
<pre><code class="language-js">abs(10)
abs(-10)
</code></pre>
<p>参数问题，js可以传任意个参数，也可以不传</p>
<p>参数进来是否存在问题？</p>
<p>假设不存在参数，如何规避？</p>
<pre><code class="language-js">function abs(x){
  //手动抛出异常
  if (typeof x!== 'number'){
    throw 'Not a Number';
  }
  if(x &gt;= 0){
    return x;
  }else {
    return -x;
  }
}
</code></pre>
<blockquote>
<p>arguments</p>
</blockquote>
<p><code>arguments</code>是一个js免费赠送的关键字</p>
<p>代表，传递进来的所有参数，是一个数组!</p>
<pre><code class="language-js">function abs(x){
  console.log(&quot;x=&gt;&quot;+x);
  for (var i = 0; i &lt; arguments.length;i++){
    console.log(arguments[i]);
  }
  if(x &gt;= 0){
    return x;
  }else {
    return -x;
  }
}
</code></pre>
<p>问题；arguments会包含所有的参数，我们有时候想使用多余的参数进行其他操作，需要排除已有的参数。</p>
<blockquote>
<p>rest</p>
</blockquote>
<p>以前</p>
<pre><code class="language-js">if(arguments.length&gt;2){
  for (var i = 2; i &lt; arguments.length; i++){
	//....
  }
}
</code></pre>
<p>es6引入的新特性，获取除了已经定义的参数之外的所有参数</p>
<pre><code class="language-js">function aaa(a,b,...rest){
  console.log(&quot;a=&gt;&quot;+a);
  console.log(&quot;b=&gt;&quot;+b);
  console.log(rest);
}
</code></pre>
<p>rest参数只能写在最后面，必须用...标识</p>
<h3 id="42-变量作用域">4.2、变量作用域</h3>
<p>在js中，vat变量实际是有作用域的</p>
<p>假设在函数体中声明，则在函数体外不可以使用（闭包）</p>
<pre><code class="language-js">function hao(){
  var x = 1;
  x = x + 1;
}
x = x +1 ; //Uncaught ReferenceError: x is not defined
</code></pre>
<p>内部函数可以访问外部函数的变量，反过来不可以</p>
<pre><code class="language-js">function hao(){
  var x = 1;
  x = x + 1;
  //内部函数可以访问外部函数的变量，反过来不可以
  function hao2(){
    var y = x + 1; //2

  }
  var z = y + 1;// Uncaught ReferenceError: y is not defined
}
</code></pre>
<p>假设内部函数变量和外部函数的变量同名，</p>
<pre><code class="language-js">function hao(){
  var x = 1;
  x = x + 1;
  //内部函数可以访问外部函数的变量，反过来不可以
  function hao2(){
    var x = 'a';
    console.log('inner'+x);

  }
  console.log('outer'+x);
  hao2();

}
hao();
</code></pre>
<p>假设在js中函数查找变量从自身函数开始，由 “内”向“外”查找。假设外部存在这个同名的，内部函数会屏蔽外部变量</p>
<blockquote>
<p>提升变量的作用域</p>
</blockquote>
<pre><code class="language-js">function hao(){
  var x = &quot;x&quot; + y;
  console.log(x);
  var y = 'y';
}
</code></pre>
<p>结果： undefined</p>
<p>说明： js执行引擎，自动提升了y的声明，但是不会提升变量y的赋值。</p>
<pre><code class="language-js">function hao2{
  var y;
  var x = 'x'+y;
  console.log(x);
  y = 'y';
}
</code></pre>
<p>这个是在js建立之初就存在的特性，规范，变量放在头部，不要乱放，便于维护。</p>
<pre><code class="language-js">function hao(){
  var x = 1;
  y = x + 1;
  z,i,z //undefined
}
</code></pre>
<blockquote>
<p>全局变量</p>
</blockquote>
<pre><code class="language-js">//全局变量
x = 1;

function f() {
  console.log(x);
}
f();
console.log(x);

</code></pre>
<p>全局对象 window</p>
<pre><code class="language-js">var x = 'xxx';
alert(x);
alert(window.x);//默认所有的全局变量都会绑定在window对象下；
</code></pre>
<p>alert()这个函数本身也是一个<code>window</code>变量</p>
<pre><code class="language-js">var x = 'xxx';
alert(x);
alert(window.x);//默认所有的全局变量都会绑定在window对象下；

var old_alert = window.alert;
old_alert(x);

window.alert = function(){

};
//发现alert失效
window.alert(123);
//恢复
window.alert = old_alert;
window.alert(123);
</code></pre>
<p>js实际上只有一个全局作用域，任何变量（函数也可以看做变量），假设没有在函数作用范围内找到，就会向外找，如果在全局作用域都没找到， 报错<code>RefrenceError</code></p>
<blockquote>
<p>规范</p>
</blockquote>
<p>由于所有的全局变量都会绑定到window上，如果不同的js文件，使用了相同的全局变量，冲突，，，如何能够减少冲突?</p>
<pre><code class="language-js">//唯一全局变量
var haoApp = {};

//定义全局变量
haoApp.name = 'haodapang';
haoApp.add = function(a,b){
  return a + b;
}
</code></pre>
<p>把自己的代码全部放到自己定义的唯一空间名字中，降低全局命名冲突的问题</p>
<blockquote>
<p>局部作用于let</p>
</blockquote>
<pre><code class="language-js">function hao(){
  for (var i = 0; i &lt; 100; i++){
    console.log(i)
  }
  console.log(i+1);//问题？i除了作用域还能用
}
</code></pre>
<p>ES6 let关键字，解决局部作用域冲突问题</p>
<pre><code class="language-js">function hao(){
  for (let i = 0; i &lt; 100; i++){
    console.log(i)
  }
  console.log(i+1);//ReferenceError: i is not defined
}
</code></pre>
<p>建议局部变量使用<code>let</code></p>
<blockquote>
<p>常量const</p>
</blockquote>
<p>在ES6之前，怎么定义常量，全部用大写字母命名的变量就是常量,建议不要修改这样的值</p>
<pre><code class="language-js">var PI = '3.14';

console.log(PI);
PI = '213';//可以改变这个值
console.log(PI);

</code></pre>
<p>在ES6中引入了常量关键字<code>const</code></p>
<pre><code class="language-js">const PI = '3.14';//只读变量
console.log(PI);
PI = '213';//Assignment to constant variable.
console.log(PI);
</code></pre>
<h3 id="43-方法">4.3、方法</h3>
<blockquote>
<p>定义方法</p>
</blockquote>
<p>方法就是把函数放在对象的里边，对象只有两个东西，方法和属性。</p>
<pre><code class="language-js">var hao = {
  name:'haodapang',
  birth:'2010',
  age: function(){
    var now = new Date().getFullYear();
    return now -this.birth;
  };
};
hao.name //属性
hao.age()//方法一定要带括号
</code></pre>
<p>this,代表什么？拆开上面的代码看看</p>
<pre><code class="language-js">function getAge(){
  var now = new Date().getFullYear();
  return now -this.birth;
};
var hao = {
  name:'haodapang',
  birth:'2010',
  age: getAge
};
hao.age()//可以
getAge()//NaN window对象没有 
</code></pre>
<p>this是无法指向的，是默认指向调用的那个对象</p>
<blockquote>
<p>apply</p>
</blockquote>
<p>在js中可以控制this的指向</p>
<pre><code class="language-js">function getAge(){
  var now = new Date().getFullYear();
  return now -this.birth;
};
var hao = {
  name:'haodapang',
  birth:'2010',
  age: getAge
};
// hao.age()//可以
// getAge()//NaN

getAge.apply(hao,[]);//this指向了hao
</code></pre>
<h2 id="5对象">5.对象</h2>
<blockquote>
<p>标准对象</p>
</blockquote>
<pre><code class="language-js">typeof '2'
&quot;string&quot;
typeof 123
&quot;number&quot;
typeof NaN
&quot;number&quot;
typeof []
&quot;object&quot;
typeof true
&quot;boolean&quot;
typeof Math.abs
&quot;function&quot;
typeof undefined
&quot;undefined&quot;
</code></pre>
<h3 id="51-date">5.1、Date</h3>
<p><strong>基本使用</strong></p>
<pre><code class="language-js">var now = new Date();
now.getFullYear();//年
now.getMonth();//月
now.getDate();//日
now.getDay();//星期几
now.getHours();//时
now.getMinutes();//分
now.getSeconds();//秒
now.getTime();//时间戳 全世界统一  1970 1.1 0：00:00 到今天的毫秒数
console.log(new Date(1578106175991));
</code></pre>
<p>转换</p>
<pre><code class="language-js">now = new Date()
Fri Sep 11 2020 22:59:06 GMT+0800 (中国标准时间)
now.toLocaleDateString();
&quot;2020/9/11&quot;
now.toLocaleString();//注意调用是一个方法，不是一个属性
&quot;2020/9/11 下午10:59:06&quot;
now.toGMTString();
&quot;Fri, 11 Sep 2020 14:59:06 GMT&quot;
now.toISOString();
&quot;2020-09-11T14:59:06.042Z&quot;
</code></pre>
<h3 id="52-json">5.2、JSON</h3>
<blockquote>
<p>json是什么</p>
</blockquote>
<ul>
<li><a href="https://baike.baidu.com/item/JSON">JSON</a>(<a href="https://baike.baidu.com/item/JavaScript">JavaScript</a> Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式。</li>
<li>简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。</li>
<li>易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。</li>
</ul>
<p>在js中一切皆为对象，任何js支持的类型都可以用json来表示</p>
<p>格式：</p>
<ul>
<li>对象都用{}</li>
<li>数组都用[]</li>
<li>所有的键值对 都是用key:value</li>
</ul>
<p>JSON和js对象的转化</p>
<pre><code class="language-js">var user = {
  name: &quot;haodapang&quot;,
  age: 3,
  sex: '男'
}

//对象转化为json
var jsonUser = JSON.stringify(user);

//字符串转化为对象 参数为json字符串
var obj = JSON.parse('{&quot;name&quot;:&quot;haodapang&quot;,&quot;age&quot;:3,&quot;sex&quot;:&quot;男&quot;}');
</code></pre>
<p>JSON和js对象的区别</p>
<pre><code class="language-js">var obj = {a:'helloa',b:'hellob'};
var json = '{&quot;a&quot;:&quot;helloa&quot;,&quot;b&quot;:&quot;hellob&quot;}';
</code></pre>
<h3 id="53-ajax">5.3、Ajax</h3>
<ul>
<li>原生的js写法 xhr异步请求</li>
<li>jquey封装好的方法  ${&quot;#name&quot;}.ajax(&quot;&quot;)</li>
<li>axios 请求</li>
</ul>
<h2 id="6面向对象编程">6.面向对象编程</h2>
<h3 id="61-什么是面向对象">6.1、什么是面向对象</h3>
<p>js java c# .....面向对象 js中有些区别</p>
<ul>
<li>类 模板</li>
<li>对象 具体的实例</li>
</ul>
<p>原型</p>
<pre><code class="language-js">var user = {
  name: &quot;haodapang&quot;,
  age: 3,
  run: function (){
    console.log(this.name + &quot;run...&quot;);
  }
};

var lisa = {
  name: &quot;lisa&quot;
};
//lisa的原型是 user
lisa.__proto__ = user;
</code></pre>
<pre><code class="language-js">function Student(name){
  this.name = name;
};

//给student新增一个方法
Student.prototype.hello = function() {
  alert('hello');

};
</code></pre>
<blockquote>
<p>class继承</p>
</blockquote>
<p><code>class</code>关键字，是在ES6引入的</p>
<p>1、定义一个类，属性，方法</p>
<pre><code class="language-js">//ES6之后==========
//定义一个学生类
class student{
  constructor(name) {
    this.name = name;

  }
  hello(){
    alert('hello');
  }
}
var hao = new student(&quot;hao&quot;);
hao.hello();
</code></pre>
<p>2、继承</p>
<pre><code class="language-js">class Student{
  constructor(name) {
    this.name = name;

  }
  hello(){
    alert('hello');
  }
}

class XiaoStudent extends Student{
  constructor(name,grade) {
    super(name);
    this.grade = grade;
  }
  myGrade(){
    alert('我成绩很好');
  }
}

var hao = new Student(&quot;hao&quot;);
var jia = new XiaoStudent('jia',80);
</code></pre>
<p>本质： 查看对象原型</p>
<figure data-type="image" tabindex="2"><img src="img/image-20200912084054631.png" alt="image-20200912084054631" loading="lazy"></figure>
<blockquote>
<p>原型链</p>
</blockquote>
<p>__ proto __:</p>
<figure data-type="image" tabindex="3"><img src="http://img.yanjiemao.top/850375-20190708152327825-11086376.png" alt="img" loading="lazy"></figure>
<h2 id="操作bom对象模型-重点">操作BOM对象模型 (重点)</h2>
<h3 id="浏览器介绍">浏览器介绍</h3>
<p>js和浏览器关系</p>
<p>js的诞生就是为了能够在浏览器中运行</p>
<p>BOM：浏览器对象模型</p>
<ul>
<li>ie</li>
<li>Chrome</li>
<li>Safari</li>
<li>Firefox （linux默认浏览器）</li>
<li>Opera（份额太小）</li>
</ul>
<h3 id="window">window</h3>
<p>window代表浏览器窗口</p>
<pre><code class="language-js">window.innerHeight
817
window.innerWidth
205
window.outerHeight
936
window.outerWidth
868
window.alert(1)
</code></pre>
<h3 id="navigator">Navigator</h3>
<p>Navigator，封装了浏览器的信息</p>
<pre><code class="language-js">navigator.appName
&quot;Netscape&quot;
navigator.appVersion
&quot;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.102 Safari/537.36 Edg/85.0.564.51&quot;
navigator.platform
&quot;Win32&quot;
navigator.userAgent
&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.102 Safari/537.36 Edg/85.0.564.51&quot;
</code></pre>
<p>大多数我们不会使用<code>navigator</code>对象，因为会被人为修改！</p>
<p>不建议使用这些属性来判断和编写代码</p>
<h3 id="screen">screen</h3>
<p>代表屏幕尺寸(缩放后的)</p>
<pre><code class="language-js">screen.width
1707
screen.height
960
</code></pre>
<h3 id="location重要">location(重要)</h3>
<p>location代表当前页面的url信息</p>
<pre><code class="language-js">host: &quot;www.baidu.com&quot;
hostname: &quot;www.baidu.com&quot;
href: &quot;https://www.baidu.com/?tn=simple&quot;
protocol: &quot;https:&quot; //协议
reload: ƒ reload() //刷新网页
//设置新的地址
location.assign('http://www.haojiayi.top');
</code></pre>
<h3 id="document">document</h3>
<p>document 代表当前的页面，html DOM文档树</p>
<p>获取具体的文档树节点</p>
<pre><code class="language-js">&lt;dl id=&quot;app&quot;&gt;
    &lt;dt&gt;java&lt;/dt&gt;
    &lt;dt&gt;javaEE&lt;/dt&gt;
    &lt;dt&gt;javaSE&lt;/dt&gt;
&lt;/dl&gt;

&lt;script&gt;
    var dl = document.getElementById('app');
&lt;/script&gt;
</code></pre>
<p>获取cookie</p>
<pre><code class="language-js">document.cookie
&quot;PSTM=1597499734; BAIDUID=9E93535966774AC39656F2C499D47525:FG=1; BD_UPN=12314753; BIDUPSID=E7E4AD5C592289F9ECC47EAE8A039E5E; BDORZ=B490B5EBF6F3CD402E515D22BCDA1598; COOKIE_SESSION=5_0_2_2_1_1_1_0_2_1_1_0_0_0_5_0_1597499240_0_1597499235%7C2%230_0_1597499235%7C1; delPer=0; BD_CK_SAM=1; PSINO=2; BDRCVFR[BDRWZOpqott]=jI8nAleq-GtpA7Eph-9Xyb8IAqs; BD_HOME=1; H_PS_PSSID=7513_32606_1444_32693_32328_7624_32691; sugstore=0&quot;
</code></pre>
<p>劫持cookie代码</p>
<p>www.taobao.com</p>
<pre><code class="language-js">&lt;script src='aaa.js'&gt;&lt;/script&gt;
//恶意人员获取cookie上传到他的服务器
</code></pre>
<p>服务器端可以设置cookie :httpOnly</p>
<blockquote>
<p>history（不建议使用）</p>
</blockquote>
<p>代表浏览器的历史记录</p>
<pre><code class="language-js">history.back()//后退
history.forword()//前进
</code></pre>
<h2 id="操作dom对象重点">操作DOM对象（重点）</h2>
<p>DOM：文档对象模型</p>
<h3 id="核心">核心</h3>
<p>浏览器网页就是一个DOM树形结构</p>
<ul>
<li>更新 更新Dom节点</li>
<li>遍历dom节点：得到dom节点</li>
<li>删除： 删除一个DOM节点</li>
<li>添加： 添加一个Dom节点</li>
</ul>
<p>要操作一个DOM节点，就必须先获得这个DOM节点</p>
<h3 id="获得dom节点">获得DOM节点</h3>
<pre><code class="language-js">//对应css选择器
var h1 = document.getElementsByTagName('h1');
var p1 = document.getElementById('p1');
var p2 = document.getElementsByClassName('p2');
var father = document.getElementById('father');
var children = father.children;//获取父节点下所有的子节点
// father.firstChild;
// father.lastChild;
</code></pre>
<p>这是原生代码，之后我们都是用jQuery</p>
<h3 id="更新节点">更新节点</h3>
<pre><code class="language-html">&lt;div id=&quot;id1&quot;&gt;
&lt;/div&gt;
&lt;script&gt;
  var id1 = document.getElementById('id1'):
&lt;/script&gt;
</code></pre>
<p>操作文本</p>
<ul>
<li>
<p><code>id1.innerText = '123'</code>修改文本的值</p>
</li>
<li>
<p><code>id1.innerHTML = '&lt;strong&gt;123&lt;/strong&gt;'</code></p>
</li>
</ul>
<pre><code class="language-js">id1.innerText = '123'
&quot;123&quot;
</code></pre>
<p>操作CSS</p>
<pre><code class="language-js">id1.style.color = 'red' //属性使用字符串
&quot;red&quot;
id1.style.fontSize= '20px'
&quot;20px&quot;
</code></pre>
<h3 id="删除节点">删除节点</h3>
<p>删除结点的步骤：先删除父节点，再通过父节点删除子节点</p>
<pre><code class="language-html">&lt;div id = &quot;father&quot;&gt;
  &lt;h1&gt;标题一&lt;/h1&gt;
&lt;p id=&quot;p1&quot;&gt;p1&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;p2&lt;/p&gt;
&lt;/div&gt;
&lt;script&gt;
  var self = document.getElementById('p1');
  var father = p1.parentElement;
  father.removeChild(p1);
  //删除是一个动态的过程，下边这种方式不可以
  father.removeChild(father.children[0])
  father.removeChild(father.children[1])
  father.removeChild(father.children[2])
&lt;/script&gt;
</code></pre>
<p>注意：删除多个节点的时候，children是在时刻发生变化的，删除节点的时候，一定要注意。</p>
<h3 id="插入节点">插入节点</h3>
<p>我们获得了某个dom节点，加入这个dom节点是空的，我们通过innerhtml就可以增加一个元素，但是dom节点已经存在元素了，我们就不能这么办了。</p>
<p>追加</p>
<pre><code class="language-html">&lt;p id=&quot;js&quot;&gt;js&lt;/p&gt;
&lt;div id = &quot;list&quot;&gt;
  &lt;p is=&quot;se&quot;&gt;javaSE&lt;/p&gt;
  &lt;p id=&quot;ee&quot;&gt;javaEE&lt;/p&gt;
  &lt;p id=&quot;me&quot;&gt;javaME&lt;/p&gt;
&lt;/div&gt;

&lt;script&gt;
  var js = document.getElementById('js');
  var list = document.getElementById('list');
  list.append(js);//追加到后面
&lt;/script&gt;
</code></pre>
<p>追加效果<br>
<img src="img/image-20200913014919939.png" alt="image-20200913014919939" style="zoom:80%;" /></p>
<h3 id="创建一个新的标签实现插入">创建一个新的标签实现插入</h3>
<pre><code class="language-js">&lt;script&gt;
  var js = document.getElementById('js');
  var list = document.getElementById('list');
  //通过js创建一个新节点
  var newP = document.createElement('p');//创建一个p标签
  newP.id = 'newP';
  newP.innerText = 'hello';
  list.appendChild(newP);
  //创建一个标签节点(通过这个属性，可以设置任意的值)
  var myScript = document.createElement('script');
  myScript.setAttribute('type','text/javascript');
  
  var myStyle = document.createElement('style');//创建了一个空style标签
  myStyle.setAttribute('type','text/javascript');
  myStyle.innerHTML = 'body{background-color:red;}';//设置标签内容

  document.getElementsByTagName('head')[0].appendChild(myStyle);
&lt;/script&gt;
</code></pre>
<h3 id="insert">insert</h3>
<pre><code class="language-js">var ee = document.getElementById('ee');
var js = document.getElementById('js');
var list = document.getElementById('list');
//要包含的节点，insetBefore(newnode,targetnode)
list.insertBefore(js,ee);
</code></pre>
<h2 id="操作表单验证">操作表单(验证)</h2>
<h3 id="表单是什么-form-dom树">表单是什么 form DOM树</h3>
<p>文本框 text<br>
下拉框  select<br>
单选框 radio<br>
多选框 checkbox<br>
隐藏域 hidden<br>
密码框 password</p>
<p>表单目的，提交信息</p>
<h3 id="获得要提交的信息">获得要提交的信息</h3>
<pre><code class="language-html">
&lt;body&gt;

  &lt;form method=&quot;post&quot;&gt;
    &lt;p&gt;
      &lt;span&gt;用户名：&lt;/span&gt;&lt;input type=&quot;text&quot; id=&quot;userName&quot;&gt;
    &lt;/p&gt;

    &lt;p&gt;
      &lt;span&gt;性别：&lt;/span&gt;
      &lt;input type= &quot;radio&quot; name=&quot;sex&quot; value=&quot;man&quot; id=&quot;boy&quot;&gt;男
      &lt;input type= &quot;radio&quot; name=&quot;sex&quot; value=&quot;women&quot; id=&quot;girl&quot;&gt;女
    &lt;/p&gt;

  &lt;/form&gt;

  &lt;script&gt;
    var input_text = document.getElementById('userName');
    var boy_radio = document.getElementById('boy');
    var gril_radio = document.getElementById('girl');
    //得到输入框的值

    //修改输入框的值
    input_text.value = '456';
    //对于单选框，多选框等等固定的值，boy_radio.value只能取到当前的值
    boy_radio.checked//查看结果是否是true，true选中，false未选中

  &lt;/script&gt;

&lt;/body&gt;
</code></pre>
<h3 id="提交表单">提交表单</h3>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;form method=&quot;post&quot;&gt;
    &lt;p&gt;
        &lt;span&gt;用户名：&lt;/span&gt;&lt;input type=&quot;text&quot; id=&quot;userName&quot;&gt;
    &lt;/p&gt;

    &lt;p&gt;
        &lt;span&gt;密码：&lt;/span&gt;&lt;input type=&quot;password&quot; id=&quot;passwords&quot;&gt;
    &lt;/p&gt;

    &lt;p&gt;
        &lt;span&gt;性别：&lt;/span&gt;
        &lt;input type= &quot;radio&quot; name=&quot;sex&quot; value=&quot;man&quot; id=&quot;boy&quot;&gt;男
        &lt;input type= &quot;radio&quot; name=&quot;sex&quot; value=&quot;women&quot; id=&quot;girl&quot;&gt;女
    &lt;/p&gt;

    &lt;!--    绑定事件，onclick,被点击--&gt;
    &lt;button type=&quot;button&quot; onclick=&quot;post()&quot;&gt;提交&lt;/button&gt;

&lt;/form&gt;

&lt;script&gt;
    function post(){
       var userName = document.getElementById('userName');
       var passwords = document.getElementById('passwords');
       console.log(userName.value);
       console.log(passwords.value);
    }


&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="前端md5加密">前端md5加密</h3>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;!--    md5工具类--&gt;
    &lt;script src=&quot;https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.min.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;form action=&quot;#&quot; method=&quot;post&quot;&gt;
    &lt;p&gt;
        &lt;span&gt;用户名：&lt;/span&gt;&lt;input type=&quot;text&quot; id=&quot;userName&quot;&gt;
    &lt;/p&gt;

    &lt;p&gt;
        &lt;span&gt;密码：&lt;/span&gt;&lt;input type=&quot;password&quot; id=&quot;input-passwords&quot;&gt;
    &lt;/p&gt;

    &lt;!--    绑定事件，onclick,被点击--&gt;
    &lt;button type=&quot;submit&quot; onclick=&quot;aaa()&quot;&gt;提交&lt;/button&gt;

&lt;/form&gt;

&lt;script&gt;
    function aaa(){
       var userName = document.getElementById('userName');
       var passwords = document.getElementById('input-passwords');
       console.log(userName.value);
       console.log(passwords.value);
       //MD5算法
        passwords.value = md5(passwords.value);
       console.log(passwords.value);
    }


&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="jquery">jQuery</h2>
<p>js和jQuery; 工具类</p>
<p>jQueryk库 ，里面存在大量的js函数</p>
<h3 id="获取jquery">获取jQuery</h3>
<p>官网https://jquery.com/download/</p>
<p>cdn直接引用</p>
<pre><code class="language-html">&lt;script src=&quot;http://code.jquery.com/jquery-2.1.1.min.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>初识jQuery</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;script src=&quot;jquery-3.5.1.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--
公式：$(selector).action()
--&gt;
&lt;a href=&quot;&quot; id=&quot;test-jquery&quot;&gt;点我&lt;/a&gt;

&lt;script&gt;
    document.getElementById('id');
    //选择器就是css的选择器
    $('#test-jquery').click(function(){
        alert('hello')
    })
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="选择器">选择器</h3>
<pre><code class="language-js">//原生js,选择器少，麻烦不好记
//标签
document.getElementsByTagName();
//id
document.getElementById();
//类
document.getElementsByClassName();
//jQuery
$('p').click();//标签选择器
$('#id1').click();//id选择器
$('.class').click();//class选择器
</code></pre>
<p><a href="https://jquery.cuishifeng.cn/">文档工具站：https://jquery.cuishifeng.cn/</a></p>
<h3 id="事件">事件</h3>
<p>鼠标事件</p>
<p>键盘事件</p>
<p>其他事件</p>
<figure data-type="image" tabindex="4"><img src="http://img.yanjiemao.top/image-20200917073554502.png" alt="image-20200917073554502" loading="lazy"></figure>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;style&gt;
        #divMove{
            width:500px;
            height:500px;
            border:1px solid red;
        }
    &lt;/style&gt;
    &lt;script src=&quot;lib/jquery-3.5.1.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--获取当前鼠标的坐标--&gt;
mouse:&lt;span id= &quot;mouseMove&quot;&gt;&lt;/span&gt;
&lt;div id=&quot;divMove&quot;&gt;
    在这里移动鼠标试试
&lt;/div&gt;
&lt;script&gt;
    //当网页元素加载完毕之后，响应事件
    $(function(){
        $('#divMove').mousemove(function (e){
            $('#mouseMove').text('x'+e.pageX+'y:'+e.pageY)
        })
    });
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="操作dom元素">操作dom元素</h3>
<p>节点文本操作</p>
<pre><code class="language-js"> $('#test-ul li[name=python]').text('1234');//更改值
 $('#test-ul li[name=python]').text();//获得值
$('#test-ul').html();//获得值
$('#test-ul').html('&lt;strong&gt;123&lt;/strong&gt;');//设置值
</code></pre>
<p>css的操作</p>
<pre><code class="language-js">$('#test-ul li[name=python]').css(&quot;color&quot;,&quot;red&quot;);
</code></pre>
<p>元素的消失与隐藏 本质：<code>display:none;</code></p>
<pre><code class="language-js">$('#test-ul li[name=python]').hide();
$('#test-ul li[name=python]').show();
</code></pre>
]]></content>
    </entry>
</feed>