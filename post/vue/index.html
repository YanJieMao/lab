<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>vue | CodeLab</title>
<link rel="shortcut icon" href="http://www.jianso.tech/lab/favicon.ico?v=1615477491850">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="http://www.jianso.tech/lab/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="vue | CodeLab - Atom Feed" href="http://www.jianso.tech/lab/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="1.vue 概述
html +css+js 视图 ：给用户看，刷新后台给的数据
网络通信 ：axios
页面跳转：vue -router
状态管理：vuex
Vue-UI: ice
webpack 打包
mvvm vm数据双向绑定
虚拟do..." />
    <meta name="keywords" content="vue" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="http://www.jianso.tech/lab">
  <img class="avatar" src="http://www.jianso.tech/lab/images/avatar.png?v=1615477491850" alt="">
  </a>
  <h1 class="site-title">
    CodeLab
  </h1>
  <p class="site-description">
    眼睫毛的CodeLab
  </p>
  <div class="menu-container">
    
      
        <a href="/lab/" class="menu">
          首页
        </a>
      
    
      
        <a href="/lab/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/lab/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/lab/post/about" class="menu">
          关于
        </a>
      
    
      
        <a href="/lab/post/daily" class="menu">
          流水账
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              vue
            </h2>
            <div class="post-info">
              <span>
                2020-08-18
              </span>
              <span>
                39 min read
              </span>
              
                <a href="http://www.jianso.tech/lab/tag/9RCbACiWT/" class="post-tag">
                  # vue
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h1 id="1vue-概述">1.vue 概述</h1>
<p>html +css+js 视图 ：给用户看，刷新后台给的数据</p>
<p>网络通信 ：axios</p>
<p>页面跳转：vue -router</p>
<p>状态管理：vuex</p>
<p>Vue-UI: ice</p>
<p>webpack 打包</p>
<p>mvvm vm数据双向绑定</p>
<p>虚拟dom：利用内存</p>
<p>大前端时代</p>
<h2 id="11-什么是mvvm">1.1、什么是MVVM</h2>
<p>​		MVVM（Model-View-ViewModel）是一种软件设计模式，由微软WPF（用于替代WinForm，以前就是用这个技术开发桌面应用程序的）和Silverlight（类似于Java Applet，简单点说就是在浏览器上运行WPF）的架构师Ken Cooper和Ted Peters开发，是一种简化用户界面的<strong>事件驱动编程方式</strong>。由John Gossman（同样也是WPF和Sliverlight的架构师）与2005年在他的博客上发表。</p>
<p>MVVM源自于经典的MVC（Model-View-Controller）模式。MVVM的核心是ViewModel层，负责转换Model中的数据对象来让数据变得更容易管理和使用。其作用如下：</p>
<ul>
<li>该层向上与视图层进行双向数据绑定</li>
<li>向下与Model层通过接口请求进行数据交互</li>
</ul>
<figure data-type="image" tabindex="1"><img src="http://img.yanjiemao.top/20200615175823742.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>MVVM已经相当成熟了，主要运用但不仅仅在网络应用程序开发中。当下流行的MVVM框架有<code>Vue.js</code>，<code>Anfular JS</code></p>
<h2 id="12-为什么要使用mvvm">1.2、为什么要使用MVVM</h2>
<p>MVVM模式和MVC模式一样，主要目的是分离视图（View）和模型（Model），有几大好处</p>
<ul>
<li><strong>低耦合</strong>： 视图（view）可以独立于Model变化和修改，一个ViewModle可以绑定到不同的View上，当VIew变化的时候Modle可以不变，当Model变化的时候View也可以不变</li>
<li><strong>可复用</strong>：可以把一些视图逻辑放置在ViewModle里边，让很多View重用这段视图</li>
<li><strong>独立开发</strong>：开发人员专注于业务逻辑和数据的开发（ViewMode）,设计人员专注于页面设计</li>
<li>容易测试：界面元素难以测试，现在可以针对viewmode来写测试代码</li>
</ul>
<figure data-type="image" tabindex="2"><img src="/img/2020061517580183.png" alt="在这里插入图片描述" loading="lazy"></figure>
<blockquote>
<p>view</p>
</blockquote>
<p>View是视图层， 也就是用户界面。前端主要由HTH L和csS来构建， 为了更方便地展现vi eu to del或者Hodel层的数据， 已经产生了各种各样的前后端模板语言， 比如FreeMarker，Thyme leaf等等， 各大MV VM框架如Vue.js.Angular JS， EJS等也都有自己用来构建用户界面的内置模板语言。</p>
<blockquote>
<p>Model</p>
</blockquote>
<p>Model是指数据模型， 泛指后端进行的各种业务逻辑处理和数据操控， 主要围绕数据库系统展开。这里的难点主要在于需要和前端约定统一的接口规则</p>
<blockquote>
<p>ViewModel</p>
</blockquote>
<p>ViewModel是由前端开发人员组织生成和维护的视图数据层。在这一层， 前端开发者对从后端获取的Model数据进行转换处理， 做二次封装， 以生成符合View层使用预期的视图数据模型。<br>
  需要注意的是View Model所封装出来的数据模型包括视图的状态和行为两部分， 而Model层的数据模型是只包含状态的</p>
<ul>
<li>比如页面的这一块展示什么，那一块展示什么这些都属于视图状态(展示)</li>
<li>页面加载进来时发生什么，点击这一块发生什么，这一块滚动时发生什么这些都属于视图行为(交互)</li>
</ul>
<p>视图状态和行为都封装在了View Model里。这样的封装使得View Model可以完整地去描述View层。由于实现了双向绑定， View Model的内容会实时展现在View层， 这是激动人心的， 因为前端开发者再也不必低效又麻烦地通过操纵DOM去更新视图。<br>
  MVVM框架已经把最脏最累的一块做好了， 我们开发者只需要处理和维护View Model， 更新数据视图就会自动得到相应更新，真正实现<code>事件驱动编程</code>。<br>
  View层展现的不是<code>Model</code>层的数据， 而是<code>ViewModel</code>的数据， 由<code>ViewModel</code>负责与<code>Model</code>层交互， 这就<strong>完全解耦了View层和Model层， 这个解耦是至关重要的， 它是前后端分离方案实施的重要一环。</strong></p>
<h2 id="13-什么是vue">1.3、什么是Vue</h2>
<p>Vue(读音/vju/， 类似于view) 是一套用于构建用户界面的渐进式框架， 发布于2014年2月。与其它大型框架不同的是， Vue被设计为可以自底向上逐层应用。Vue的核心库只关注视图层， 不仅易于上手， 还便于与第三方库(如：vue-router，vue-resource，vue x) 或既有项目整合。</p>
<blockquote>
<p>MVVM模式的实现者</p>
</blockquote>
<ul>
<li>Model：模型层， 在这里表示JavaScript对象</li>
<li>View：视图层， 在这里表示DOM(HTML操作的元素)</li>
<li>ViewModel：连接视图和数据的中间件， Vue.js就是MVVM中的View Model层的实现者</li>
</ul>
<p>在MVVM架构中， 是不允许数据和视图直接通信的， 只能通过ViewModel来通信， 而View Model就是定义了一个Observer观察者</p>
<ul>
<li>ViewModel能够观察到数据的变化， 并对视图对应的内容进行更新</li>
<li>ViewModel能够监听到视图的变化， 并能够通知数据发生改变</li>
</ul>
<p>至此， 我们就明白了， Vue.js就是一个MV VM的实现者， 他的核心就是实现了DOM监听与数据绑定</p>
<blockquote>
<p>为什么使用Vue.js</p>
</blockquote>
<ul>
<li>轻量级， 体积小是一个重要指标。Vue.js压缩后有只有20多kb(Angular压缩后56kb+，React压缩后44kb+)</li>
<li>移动优先。更适合移动端， 比如移动端的Touch事件</li>
<li>易上手，学习曲线平稳，文档齐全</li>
<li>吸取了Angular(模块化) 和React(虚拟DOＭ) 的长处， 并拥有自己独特的功能，如：计算属性</li>
<li>开源，社区活跃度高</li>
</ul>
<h2 id="14-第一个vue程序">1.4、第一个Vue程序</h2>
<p>【说明】IDEA可以安装Vue的插件!<br>
注意：Vue不支持IE 8及以下版本， 因为Vue使用了IE 8无法模拟的ECMAScript 5特性。但它支持所有兼容ECMAScript 5的浏览器。</p>
<p><strong>下载版本</strong></p>
<ul>
<li>开发版本
<ul>
<li>包含完整的警告和调试模式：https：//yuejs.org/js/vue.js</li>
<li>删除了警告， 30.96KBmin+gzip：https：//vuejs.org/js/vue.min.js</li>
</ul>
</li>
<li>CDN
<ul>
<li><code>&lt;script src=“https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.js”&gt;&lt;/script&gt;</code></li>
<li><code>&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js&quot;&gt;&lt;/script&gt;</code></li>
</ul>
</li>
</ul>
<p>第一个程序</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;

&lt;/head&gt;hello2
&lt;body&gt;
&lt;h1&gt;郝大胖&lt;/h1&gt;
&lt;!--view层变成了模板--&gt;
&lt;div id=&quot;app&quot;&gt;
        {{message}}
&lt;/div&gt;


&lt;!--导入vue.js--&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    var vm = new Vue({
        el: &quot;#app&quot;,
        //modle,数据
        data: {
            message: &quot;hello,vue!&quot;
        }
    })
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ul>
<li><code>el: '#vue'</code>：绑定元素的ID</li>
<li><code>data:{message:'Hello Vue!'}</code>：数据对象中有一个名为message的属性，并设置了初始值 Hello Vue！</li>
</ul>
<p>说明：只需要在绑定的元素中使用双花括号将Vue创建的名为message属性包裹起来， 即可实现数据绑定功能， 也就实现了View Model层所需的效果， 是不是和EL表达式非常像?</p>
<blockquote>
<p>浏览器测试</p>
</blockquote>
<p>为了能够更直观的体验Vue带来的数据绑定功能， 我们需要在浏览器测试一番， 操作流程如下：<br>
  1、在浏览器上运行第一个Vue应用程序， 进入开发者工具<br>
  2、在控制台输入vm.message=‘HelloWorld’， 然后回车， 你会发现浏览器中显示的内容会直接变成HelloWorld<br>
  此时就可以在控制台直接输入vm.message来修改值， 中间是可以省略data的， 在这个操作中， 我并没有主动操作DOM， 就让页面的内容发生了变化， 这就是借助了Vue的数据绑定功能实现的； MV VM模式中要求View Model层就是使用观察者模式来实现数据的监听与绑定， 以做到数据与视图的快速响应。</p>
<h1 id="2基础语法指令">2.基础语法指令</h1>
<h2 id="21-v-bind">2.1、v-bind</h2>
<p>我们已经成功创建了第一个Vue应用!看起来这跟渲染一个字符串模板非常类似， 但是Vue在背后做了大量工作。现在数据和DOM已经被建立了关联， 所有东西都是响应式的。我们在控制台操作对象属性，界面可以实时更新!<br>
我们还可以使用v-bind来绑定元素特性!</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot; xmlns:v-bind=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;

&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;郝大胖&lt;/h1&gt;
&lt;!--view层变成了模板--&gt;
&lt;div id=&quot;app&quot;&gt;
    &lt;span v-bind:title=&quot;message&quot;&gt;
    鼠标悬停几秒
    &lt;/span&gt;
&lt;/div&gt;


&lt;!--导入vue.js--&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    var vm = new Vue({
        el: &quot;#app&quot;,
        //modle,数据
        data: {
            message: &quot;hello,vue!&quot;
        }
    })
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>​			你看到的v-bind等被称为指令。指令带有前缀v以表示它们是Vue提供的特殊特性。可能你已经猜到了， 它们会在渲染的DOM上应用特殊的响应式行为在这里，该指令的意思是：“将这个元素节点的title特性和Vue实例的message属性保持一致”。<br>
  如果你再次打开浏览器的JavaScript控制台， 输入app， message=‘新消息’，就会再一次看到这个绑定了title特性的HTML已经进行了更新。</p>
<h2 id="22-v-if-v-else">2.2、v-if v-else</h2>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot; xmlns:v-bind=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;

&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;郝大胖&lt;/h1&gt;
&lt;!--view层变成了模板--&gt;
&lt;div id=&quot;app&quot;&gt;
   &lt;h1 v-if=&quot;type==='A'&quot;&gt;A&lt;/h1&gt;
   &lt;h1 v-else-if=&quot;type==='B'&quot;&gt;B&lt;/h1&gt;
   &lt;h1 v-else-if=&quot;type==='C'&quot;&gt;C&lt;/h1&gt;
   &lt;h1 v-else&gt;D&lt;/h1&gt;
&lt;/div&gt;


&lt;!--导入vue.js--&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    var vm = new Vue({
        el: &quot;#app&quot;,
        //modle,数据
        data: {
            type: 'A'
        }
    })
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>注：<code>===</code>三个等号在JS中表示绝对等于(就是数据与类型都要相等)上代码：</p>
<h2 id="23-v-for">2.3、v-for</h2>
<p>格式说明</p>
<p><code>items</code>是数组，<code>item</code>是数组元素迭代的别名。我们之后学习的Thymeleaf模板引擎的语法和这个十分的相似！</p>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
    &lt;li v-for=&quot;(item,index) in items&quot;&gt;
        {{item.message}}---{{index}}
    &lt;/li&gt;

&lt;/div&gt;
</code></pre>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot; xmlns:v-bind=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;

&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;郝大胖&lt;/h1&gt;
&lt;!--view层变成了模板--&gt;
&lt;div id=&quot;app&quot;&gt;
    &lt;li v-for=&quot;item in items&quot;&gt;
        {{item.message}}---{{index}}
    &lt;/li&gt;
&lt;/div&gt;


&lt;!--导入vue.js--&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    var vm = new Vue({
        el: &quot;#app&quot;,
        //modle,数据
        data: {
            items:[
                {message:'郝大胖'},
                {message:'啦啦啦'},
                {message:'呀呀呀'}

            ]
        }
    })
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>在控制台输入<code>vm.items.push({message：'你好呀'})</code>，尝试追加一条数据，你会发现浏览器中显示的内容会增加一条 你好呀.</p>
<h2 id="24-v-on">2.4、v-on</h2>
<p><code>v-on</code>监听事件<br>
 事件有Vue的事件、和前端页面本身的一些事件!我们这里的<code>click</code>是vue的事件， 可以绑定到Vue中的<code>methods</code>中的方法事件!</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot; xmlns:v-on=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;

&lt;/head&gt;
&lt;body&gt;

&lt;div id=&quot;app&quot;&gt;
&lt;button v-on:click=&quot;sayHi&quot;&gt;点我&lt;/button&gt;
&lt;/div&gt;


&lt;!--导入vue.js--&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    var vm = new Vue({
        el: &quot;#app&quot;,

        data: {
            message:&quot;郝大胖&quot;
        },
        methods:{//方法必须定义在Vue的Methods对象中
            sayHi: function (){
                alert(this.message);
            }

        }

    })
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>Vue还有一些基本的使用方式， 大家有需要的可以再跟着官方文档看看https://cn.vuejs.org/</p>
<h1 id="3表单双向数据绑定">3.表单双向数据绑定</h1>
<h2 id="31-什么是双向数据绑定">3.1、什么是双向数据绑定</h2>
<p>​		Vue.js是一个MV VM框架， 即数据双向绑定， 即当数据发生变化的时候， 视图也就发生变化， 当视图发生变化的时候，数据也会跟着同步变化。这也算是Vue.js的精髓之处了。<br>
  值得注意的是，我们所说的数据双向绑定，一定是对于UI控件来说的非UI控件不会涉及到数据双向绑定。单向数据绑定是使用状态管理工具的前提。如果我们使用vue x那么数据流也是单项的，这时就会和双向数据绑定有冲突。</p>
<p><strong>为什么要实现数据的双向绑定？</strong></p>
<p>在<code>Vue.js</code>中，如果使用<code>vuex</code>， 实际上数据还是单向的， 之所以说是数据双向绑定，这是用的UI控件来说， 对于我们处理表单， <code>Vue.js</code>的双向数据绑定用起来就特别舒服了。即两者并不互斥，在全局性数据流使用单项，方便跟踪；局部性数据流使用双向，简单易操作。</p>
<h2 id="32-在表单中使用双向数据绑定">3.2、在表单中使用双向数据绑定</h2>
<p>可以用<code>v-model</code>指令在表单、及元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇， 但<code>v-model</code>本质上不过是语法糖。它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。<br>
  注意：<code>v-model</code>会忽略所有表单元素的<code>value</code>、<code>checked</code>、<code>selected</code>特性的初始值而总是将<code>Vue</code>实例的数据作为数据来源。你应该通过<code>JavaScript</code>在组件的<code>data</code>选项中声明初始值!</p>
<p>1.单行文本</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id=&quot;app&quot;&gt;
    输入的文本：&lt;input type=&quot;text&quot; v-model=&quot;message&quot; value=&quot;hello&quot;&gt;{{message}}
&lt;/div&gt;

&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    var vm = new Vue({
        el:&quot;#app&quot;,
        data:{
            message:&quot;&quot;
        }
    });
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<p>2.多行文本</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id=&quot;app&quot;&gt;
   多行文本：&lt;textarea v-model=&quot;pan&quot;&gt;&lt;/textarea&gt;&amp;nbsp;&amp;nbsp;多行文本是：{{pan}}
&lt;/div&gt;

&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    var vm = new Vue({
        el:&quot;#app&quot;,
        data:{
            message:&quot;Hello hello!&quot;
        }
    });
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>3.单复选框</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div id=&quot;app&quot;&gt;
    单复选框：
    &lt;input type=&quot;checkbox&quot; id=&quot;checkbox&quot; v-model=&quot;checked&quot;&gt;
    &amp;nbsp;&amp;nbsp;
    &lt;label for=&quot;checkbox&quot;&gt;{{checked}}&lt;/label&gt;
&lt;/div&gt;

&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    var vm = new Vue({
        el:&quot;#app&quot;,
        data:{
            checked:false
        }
    });
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>4.多复选框</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div id=&quot;app&quot;&gt;
    多复选框：
    &lt;input type=&quot;checkbox&quot; id=&quot;jack&quot; value=&quot;Jack&quot; v-model=&quot;checkedNames&quot;&gt;
    &amp;nbsp;&amp;nbsp;
    &lt;label for=&quot;jack&quot;&gt;Jack&lt;/label&gt;
    &lt;input type=&quot;checkbox&quot; id=&quot;join&quot; value=&quot;Join&quot; v-model=&quot;checkedNames&quot;&gt;
    &amp;nbsp;&amp;nbsp;
    &lt;label for=&quot;join&quot;&gt;Jack&lt;/label&gt;
    &lt;input type=&quot;checkbox&quot; id=&quot;mike&quot; value=&quot;Mike&quot; v-model=&quot;checkedNames&quot;&gt;
    &amp;nbsp;&amp;nbsp;
    &lt;label for=&quot;mike&quot;&gt;Mike&lt;/label&gt;
    &lt;span&gt;选中的值：{{checkedNames}}&lt;/span&gt;
&lt;/div&gt;

&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    var vm = new Vue({
        el:&quot;#app&quot;,
        data:{
            checkedNames:[]
        }
    });
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>5.单选按钮</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div id=&quot;app&quot;&gt;
    单选框按钮
    &lt;input type=&quot;radio&quot; id=&quot;one&quot; value=&quot;One&quot; v-model=&quot;picked&quot;&gt;
    &lt;label for=&quot;one&quot;&gt;One&lt;/label&gt;
    &lt;input type=&quot;radio&quot; id=&quot;two&quot; value=&quot;Two&quot; v-model=&quot;picked&quot;&gt;
    &lt;label for=&quot;two&quot;&gt;Two&lt;/label&gt;
    &lt;span&gt;选中的值：{{picked}}&lt;/span&gt;
&lt;/div&gt;

&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    var vm = new Vue({
        el:&quot;#app&quot;,
        data:{
            picked:'Two'
        }
    });
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>6.下拉框</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id=&quot;app&quot;&gt;

    下拉框:
    &lt;select v-model=&quot;pan&quot;&gt;
        &lt;option value=&quot;&quot; disabled&gt;---请选择---&lt;/option&gt;
        &lt;option&gt;A&lt;/option&gt;
        &lt;option&gt;B&lt;/option&gt;
        &lt;option&gt;C&lt;/option&gt;
        &lt;option&gt;D&lt;/option&gt;
    &lt;/select&gt;
    &lt;span&gt;value:{{pan}}&lt;/span&gt;



&lt;/div&gt;

&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    var vm = new Vue({
        el:&quot;#app&quot;,
        data:{
            pan:&quot;A&quot;
        }
    });
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>注意：<code>v-model</code>表达式的初始值未能匹配任何选项，元系将被渲染为“未选中”状态。 在iOS中， 这会使用户无法选择第一个选项，因为这样的情况下，iOS不会触发<code>change</code>事件。因此，更推荐像上面这样提供一个值为空的禁用选项。</p>
<h1 id="4组件">4.组件</h1>
<h2 id="41-什么是组件">4.1、什么是组件</h2>
<p>组件是可复用的<code>Vue</code>实例， 说白了就是一组可以重复使用的模板， 跟<code>JSTL</code>的自定义标签、<code>Thymeleal</code>的<code>th:fragment</code>等框架有着异曲同工之妙，通常一个应用会以一棵嵌套的组件树的形式来组织：</p>
<figure data-type="image" tabindex="3"><img src="http://img.yanjiemao.top/20200616171528707.png" alt="在这里插入图片描述" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="http://img.yanjiemao.top/20200616171908189.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>例如，你可能会有页头、侧边栏、内容区等组件，每个组件又包含了其它的像导航链接、博文之类的组件。</p>
<h2 id="42-第一个组件">4.2、第一个组件</h2>
<p>注意：在实际开发中，我们并不会用以下方式开发组件，而是采用<code>vue-cli</code>创建，<code>vue</code>模板文件的方式开发，以下方法只是为了让大家理解什么是组件。</p>
<p><strong>使用<code>Vue.component()</code>方法注册组件，格式如下：</strong></p>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
  &lt;pan&gt;&lt;/pan&gt;
&lt;/div&gt;

&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    //先注册组件
    Vue.component(&quot;pan&quot;,{
        
        template:'&lt;li&gt;Hello&lt;/li&gt;'

    });
    //再实例化Vue
    var vm = new Vue({
        el:&quot;#app&quot;,
    });
&lt;/script&gt;

</code></pre>
<p>说明：</p>
<ul>
<li><code>Vue.component()</code>：注册组件</li>
<li><code>pan</code>：自定义组件的名字</li>
<li><code>template</code>：组件的模板</li>
</ul>
<h2 id="43-使用props传递参数">4.3、使用props传递参数</h2>
<p>像上面那样用组件没有任何意义，所以我们是需要传递参数到组件的，此时就需要使用<code>props</code>属性了！<br>
<strong>注意：默认规则下props属性里的值不能为大写；</strong></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot; xmlns:v-on=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;

&lt;/head&gt;
&lt;body&gt;

&lt;div id=&quot;app&quot;&gt;
&lt;!--    组件，传递给组件中的值：props--&gt;
    &lt;hao v-for=&quot;item in items&quot; v-bind:haodapang=&quot;item&quot;&gt;&lt;/hao&gt;

&lt;/div&gt;


&lt;!--导入vue.js--&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    //定义一个Vue组件component
    Vue.component(&quot;hao&quot;,{
        props: ['haodapang'],
        template: '&lt;li&gt;{{haodapang}}&lt;/li&gt;'

    });
    var vm = new Vue({
        el: &quot;#app&quot;,
        data:{
            items: [&quot;java&quot;,&quot;linux&quot;,&quot;前端&quot;]
        }

    });
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><strong>说明</strong>：</p>
<ul>
<li><code>v-for=&quot;item in items&quot;</code>：遍历<code>Vue</code>实例中定义的名为<code>items</code>的数组，并创建同等数量的组件</li>
<li><code>v-bind:haodapang=&quot;item&quot;</code>：将遍历的<code>item</code>项绑定到组件中<code>props</code>定义名为<code>item</code>属性上；= 号左边的<code>haodapang</code>为<code>props</code>定义的属性名，右边的为<code>item in items</code> 中遍历的item项的值</li>
</ul>
<h1 id="5axios异步通信">5.Axios异步通信</h1>
<h2 id="51-什么是axios">5.1、什么是Axios</h2>
<p>Axios是一个开源的可以用在浏览器端和<code>Node JS</code>的异步通信框架， 她的主要作用就是实现AJAX异步通信，其功能特点如下：</p>
<ul>
<li>从浏览器中创建<code>XMLHttpRequests</code></li>
<li>从node.js创建http请求</li>
<li>支持Promise API[JS中链式编程]</li>
<li>拦截请求和响应</li>
<li>转换请求数据和响应数据</li>
<li>取消请求</li>
<li>自动转换JSON数据</li>
<li>客户端支持防御XSRF(跨站请求伪造)</li>
</ul>
<p>GitHub：https://github.com/axios/axios<br>
  中文文档：http://www.axios-js.com/</p>
<blockquote>
<p>为什么要使用Axios</p>
</blockquote>
<p>由于<code>Vue.js</code>是一个视图层框架并且作者(尤雨溪) 严格准守SoC(关注度分离原则)所以<code>Vue.js</code>并不包含AJAX的通信功能， 为了解决通信问题， 作者单独开发了一个名为<code>vue-resource</code>的插件， 不过在进入2.0版本以后停止了对该插件的维护并推荐了<code>Axios</code>框架。少用jQuery， 因为它操作Dom太频繁!</p>
<h2 id="52-第一个axios应用程序">5.2、第一个Axios应用程序</h2>
<p>咱们开发的接口大部分都是采用JSON格式， 可以先在项目里模拟一段JSON数据， 数据内容如下：创建一个名为data.json的文件并填入上面的内容， 放在项目的根目录下</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;郝大胖&quot;,
  &quot;url&quot;: &quot;https://blog.jianso.tech/&quot;,
  &quot;page&quot;: 1,
  &quot;isNonProfit&quot;: true,
  &quot;address&quot;: {
    &quot;street&quot;: &quot;光荣道&quot;,
    &quot;city&quot;: &quot;天津&quot;,
    &quot;country&quot;: &quot;中国&quot;
  }

}

</code></pre>
<p>测试代码</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div id=&quot;vue&quot;&gt;
    &lt;div&gt;名字：{{info.name}}&lt;/div&gt;
    &lt;div&gt;地址：{{info.address.street}}&lt;/div&gt;
    &lt;div&gt;链接：&lt;a v-binf:href=&quot;info.url&quot; target=&quot;_blank&quot;&gt;{{info.url}}&lt;/a&gt; &lt;/div&gt;
&lt;/div&gt;

&lt;!--引入js文件--&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    var vm = new Vue({
        el:&quot;#vue&quot;,
        //data: 属性 data方法
        data(){
            return{
                //请求的返回参数格适，必须和json字符串一样
                info:{
                    name: null,
                    address: {
                        street: null,
                        city: null,
                        country: null
                    }

                }

            }

        },
        mounted(){//钩子函数 链式编程 es6新特性
            axios.get('data.json').then(response=&gt;{this.info=(response.data)})

        }
    });

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>说明：</p>
<ol>
<li>在这里使用了v-bind将a:href的属性值与Vue实例中的数据进行绑定</li>
<li>使用axios框架的get方法请求AJAX并自动将数据封装进了Vue实例的数据对象中</li>
<li>我们在data中的数据结构必须和<code>Ajax</code>响应回来的数据格式匹配！</li>
</ol>
<h2 id="53-vue的生命周期">5.3、Vue的生命周期</h2>
<p>官方文档：https://cn.vuejs.org/v2/guide/instance.html#生命周期图示<br>
  Vue实例有一个完整的生命周期，也就是从开始创建初女台化数据、编译模板、挂载DOM、渲染一更新一渲染、卸载等一系列过程，我们称这是Vue的生命周期。通俗说就是Vue实例从创建到销毁的过程，就是生命周期。<br>
  在Vue的整个生命周期中，它提供了一系列的事件，可以让我们在事件触发时注册JS方法，可以让我们用自己注册的JS方法控制整个大局，在这些事件响应方法中的this直接指向的是Vue的实例。</p>
<figure data-type="image" tabindex="5"><img src="http://img.yanjiemao.top/20200616222020393.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="6计算属性-内容分发-自定义事件">6.计算属性、内容分发、自定义事件</h1>
<h2 id="61-什么是计算属性">6.1、什么是计算属性</h2>
<p>计算属性的重点突出在<code>属性</code>两个字上(属性是名词)，首先它是个<code>属性</code>其次这个属性有<code>计算</code>的能力(计算是动词)，这里的<code>计算</code>就是个函数：简单点说，它就是一个能够将计算结果缓存起来的属性(将行为转化成了静态的属性)，仅此而已；可以想象为缓存!</p>
<p>代码</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--view层，模板--&gt;
&lt;div id=&quot;app&quot;&gt;
    &lt;p&gt;currentTime1:{{currentTime1()}}&lt;/p&gt;
    &lt;p&gt;currentTime2:{{currentTime2}}&lt;/p&gt;
&lt;/div&gt;

&lt;!--1.导入Vue.js--&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    var vm = new Vue({
        el:&quot;#app&quot;,
        data:{
          message:&quot;pan&quot;
        },
        methods:{
            currentTime1:function(){
                return Date.now();//返回一个时间戳
            }
        },
        computed:{
            currentTime2:function(){//计算属性：methods，computed方法名不能重名，重名之后，只会调用methods的方法
                this.message;
                return Date.now();//返回一个时间戳
            }
        }
    });
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<p>注意：methods和computed里的东西不能重名</p>
<blockquote>
<p>说明：</p>
</blockquote>
<ul>
<li>
<p>methods：定义方法， 调用方法使用currentTime1()， 需要带括号</p>
</li>
<li>
<p>computed：定义计算属性， 调用属性使用currentTime2， 不需要带括号：this.message是为了能够让currentTime2观察到数据变化而变化</p>
</li>
<li>
<p>如何在方法中的值发生了变化，则缓存就会刷新!可以在控制台使用<code>vm.message=”q in jiang&quot;</code>， 改变下数据的值，再次测试观察效果!</p>
<p><strong>结论：</strong><br>
  调用方法时，每次都需要讲行计算，既然有计算过程则必定产生系统开销，那如果这个结果是不经常变化的呢?此时就可以考虑将这个结果缓存起来，采用计算属性可以很方便的做到这点，<strong>计算属性的主要特性就是为了将不经常变化的计算结果进行缓存，以节约我们的系统开销；</strong></p>
</li>
</ul>
<h2 id="62-内容分发">6.2、内容分发</h2>
<p>在<code>Vue.js</code>中我们使用<code>&lt;slot&gt;</code>元素作为承载分发内容的出口，作者称其为插槽，可以应用在组合组件的场景中；</p>
<p>举例</p>
<p>比如准备制作一个待办事项组件(todo) ， 该组件由待办标题(todo-title) 和待办内容(todo-items)组成，但这三个组件又是相互独立的，该如何操作呢?</p>
<p>第一步 定义一个待办事件的组件</p>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
    &lt;todo&gt;&lt;/todo&gt;
&lt;/div&gt;
&lt;!--1.导入Vue.js--&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    Vue.component('todo',{
        template:'&lt;div&gt;\
                &lt;div&gt;代办事项&lt;/div&gt;\
                &lt;ul&gt;\
                    &lt;li&gt;学习狂神说Java&lt;/li&gt;\
                &lt;/ul&gt;\
            &lt;/div&gt;'
    })
&lt;/script&gt;

</code></pre>
<p>第二步 我们需要让，代办事项的标题和值实现动态绑定，怎么做呢？我们可以留一个插槽！</p>
<p>1-将上面的代码留出一个插槽，即slot</p>
<pre><code class="language-html"> Vue.component('todo',{
        template:'&lt;div&gt;\
                &lt;slot name=&quot;todo-title&quot;&gt;&lt;/slot&gt;\
                &lt;ul&gt;\
                    &lt;slot name=&quot;todo-items&quot;&gt;&lt;/slot&gt;\
                &lt;/ul&gt;\
            &lt;/div&gt;'
    });

</code></pre>
<p>2-定义一个名为todo-title的待办标题组件 和 todo-items的待办内容组件</p>
<pre><code class="language-js">Vue.component('todo-title',{
props:['title'],
template:'&lt;div&gt;{{title}}&lt;/div&gt;'
});
//这里的index，就是数组的下标，使用for循环遍历的时候，可以循环出来！
Vue.component(&quot;todo-items&quot;,{
props:[&quot;item&quot;,&quot;index&quot;],
template:&quot;&lt;li&gt;{{index+1}},{{item}}&lt;/li&gt;&quot;
});
</code></pre>
<p>3-实例化Vue并初始化数据</p>
<pre><code class="language-js"> var vm = new Vue({
        el:&quot;#vue&quot;,
        data:{
            todoItems:['test1','test2','test3']
        }
    });

</code></pre>
<p>4-将这些值，通过插槽插入</p>
<pre><code class="language-js">&lt;div id=&quot;vue&quot;&gt;
    &lt;todo&gt;
        &lt;todo-title slot=&quot;todo-title&quot; title=&quot;郝大胖系列课程&quot;&gt;&lt;/todo-title&gt;
        &lt;!--&lt;todo-items slot=&quot;todo-items&quot; v-for=&quot;{item,index} in todoItems&quot; v-bind:item=&quot;item&quot;&gt;&lt;/todo-items&gt;--&gt;
        &lt;!--如下为简写--&gt;
        &lt;todo-items slot=&quot;todo-items&quot; v-for=&quot;item in todoItems&quot; :item=&quot;item&quot;&gt;&lt;/todo-items
    &lt;/todo&gt;
&lt;/div&gt;

</code></pre>
<p>说明：我们的todo-title和todo-items组件分别被分发到了todo组件的todo-title和todo-items插槽中</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--view层，模板--&gt;
&lt;div id=&quot;vue&quot;&gt;
    &lt;todo&gt;
        &lt;todo-title slot=&quot;todo-title&quot; title=&quot;title&quot;&gt;&lt;/todo-title&gt;
        &lt;!--&lt;todo-items slot=&quot;todo-items&quot; v-for=&quot;{item,index} in todoItems&quot; v-bind:item=&quot;item&quot;&gt;&lt;/todo-items&gt;--&gt;
        &lt;!--如下为简写--&gt;
        &lt;todo-items slot=&quot;todo-items&quot; v-for=&quot;item in todoItems&quot; :item=&quot;item&quot;&gt;&lt;/todo-items
    &lt;/todo&gt;
&lt;/div&gt;
&lt;!--1.导入Vue.js--&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    Vue.component('todo',{
        template:'&lt;div&gt;\
                &lt;slot name=&quot;todo-title&quot;&gt;&lt;/slot&gt;\
                &lt;ul&gt;\
                    &lt;slot name=&quot;todo-items&quot;&gt;&lt;/slot&gt;\
                &lt;/ul&gt;\
            &lt;/div&gt;'
    });
    Vue.component('todo-title',{
        props:['title'],
        template:'&lt;div&gt;{{title}}&lt;/div&gt;'
    });
    //这里的index，就是数组的下标，使用for循环遍历的时候，可以循环出来！
    Vue.component(&quot;todo-items&quot;,{
        props:[&quot;item&quot;,&quot;index&quot;],
        template:&quot;&lt;li&gt;{{index+1}},{{item}}&lt;/li&gt;&quot;
    });

    var vm = new Vue({
        el:&quot;#vue&quot;,
        data:{
            title:&quot;郝大胖系列课程&quot;,
            todoItems:['test1','test2','test3']
        }
    });
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<h2 id="63-自定义事件">6.3、自定义事件</h2>
<p>​    通以上代码不难发现，数据项在Vue的实例中， 但删除操作要在组件中完成， 那么组件如何才能删除Vue实例中的数据呢?此时就涉及到参数传递与事件分发了， Vue为我们提供了自定义事件的功能很好的帮助我们解决了这个问题； 使用this.$emit(‘自定义事件名’， 参数) ， 操作过程如下：<br>
1-在vue的实例中增加了methods对象并定义了一个名为removeTodoltems的方法</p>
<pre><code class="language-js">var vm = new Vue({
        el:&quot;#vue&quot;,
        data:{
            title_text:&quot;秦老师系列课程&quot;,
            todoItems:['test1','test2','test3']
        },
        methods:{
            removeItems:function(index){
                console.log(&quot;删除了&quot;+this.todoItems[index]+&quot;OK&quot;);
                //splice（） 方法向/从数组中添加/删除项目，然后返回被删除的项目，其中index
                this.todoItems.splice(index,1);
            }
        }
    });

</code></pre>
<p>2-修改todo-items待办内容组件的代码，增加一个删除按钮，并且绑定事件！</p>
<pre><code class="language-js"> Vue.component(&quot;todo-items&quot;,{
        props:[&quot;item_p&quot;,&quot;index_p&quot;],
        template:&quot;&lt;li&gt;{{index_p+1}},{{item_p}} &lt;button @click='remove'&gt;删除&lt;/button&gt;&lt;/li&gt;&quot;,
        methods:{
            remove:function (index) {
            //这里的remove是自定义事件名称，需要在HTML中使用v-on:remove的方式
                //this.$emit 自定义事件分发
                this.$emit('remove',index);
            }
        }
    });

</code></pre>
<p>3-修改todo-items待办内容组件的HTML代码，增加一个自定义事件，比如叫remove，可以和组件的方法绑定，然后绑定到vue的方法！</p>
<pre><code class="language-js">&lt;!--增加了v-on:remove=&quot;removeTodoItems(index)&quot;自定义事件，该组件会调用Vue实例中定义的--&gt;
&lt;todo-items slot=&quot;todo-items&quot; v-for=&quot;(item,index) in todoItems&quot;
                    :item_p=&quot;item&quot; :index_p=&quot;index&quot; v-on:remove=&quot;removeItems(index)&quot; :key=&quot;index&quot;&gt;&lt;/todo-items&gt;
 
</code></pre>
<p><strong>对上一个代码进行修改，实现删除功能</strong></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--view层，模板--&gt;
&lt;div id=&quot;vue&quot;&gt;
    &lt;todo&gt;
        &lt;todo-title slot=&quot;todo-title&quot; :title=&quot;title_text&quot;&gt;&lt;/todo-title&gt;
        &lt;!--&lt;todo-items slot=&quot;todo-items&quot; v-for=&quot;(item,index) in todoItems&quot; v-bind:item=&quot;item&quot;&gt;&lt;/todo-items&gt;--&gt;
        &lt;!--如下为简写--&gt;
        &lt;todo-items slot=&quot;todo-items&quot; v-for=&quot;(item,index) in todoItems&quot;
                    :item_p=&quot;item&quot; :index_p=&quot;index&quot; v-on:remove=&quot;removeItems(index)&quot; :key=&quot;index&quot;&gt;&lt;/todo-items&gt;
    &lt;/todo&gt;
&lt;/div&gt;
&lt;!--1.导入Vue.js--&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    Vue.component('todo',{
        template:'&lt;div&gt;\
                &lt;slot name=&quot;todo-title&quot;&gt;&lt;/slot&gt;\
                &lt;ul&gt;\
                    &lt;slot name=&quot;todo-items&quot;&gt;&lt;/slot&gt;\
                &lt;/ul&gt;\
            &lt;/div&gt;'
    });
    Vue.component('todo-title',{
        props:['title'],
        template:'&lt;div&gt;{{title}}&lt;/div&gt;'
    });
    //这里的index，就是数组的下标，使用for循环遍历的时候，可以循环出来！
    Vue.component(&quot;todo-items&quot;,{
        props:[&quot;item_p&quot;,&quot;index_p&quot;],
        template:&quot;&lt;li&gt;{{index_p+1}},{{item_p}} &lt;button @click='remove_methods'&gt;删除&lt;/button&gt;&lt;/li&gt;&quot;,
        methods:{
            remove_methods:function (index) {
                //this.$emit 自定义事件分发
                this.$emit('remove',index);
            }
        }
    });

    var vm = new Vue({
        el:&quot;#vue&quot;,
        data:{
            title_text:&quot;郝大胖系列课程&quot;,
            todoItems:['test1','test2','test3']
        },
        methods:{
            removeItems:function(index){
                console.log(&quot;删除了&quot;+this.todoItems[index]+&quot;OK&quot;);
                this.todoItems.splice(index,1);
            }
        }
    });
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<p>逻辑理解</p>
<figure data-type="image" tabindex="6"><img src="/img/image-20200927121637115.png" alt="image-20200927121637115" loading="lazy"></figure>
<h2 id="64-vue入门小结">6.4、vue入门小结</h2>
<p>核心：数据驱动，组件化</p>
<p>优点：借鉴了AngularJS的模块化开发和React的虚拟Dom，虚拟Dom就是把Demo操作放到内存中执行；</p>
<p>常用的属性：</p>
<ul>
<li>v-if</li>
<li>v-else-if</li>
<li>v-else</li>
<li>v-for</li>
<li>v-on绑定事件，简写@</li>
<li>v-model数据双向绑定</li>
<li>v-bind给巨剑绑定参数，简写：</li>
</ul>
<p>组件化：</p>
<ul>
<li>组合组件slot插槽</li>
<li>组件内部绑定事件需要使用到<code>this.$emit(&quot;事件名&quot;,参数);</code></li>
<li>计算属性的特色，缓存计算数据</li>
</ul>
<p>遵循SoC关注度分离原则，Vue是纯粹的视图框架，并不包含，比如Ajax之类的通信功能，为了解决通信问题，我们需要使用Axios框架做异步通信；</p>
<h2 id="说明">说明</h2>
<p>Vue的开发都是要基于NodeJS，实际开发采用Vue-cli脚手架开发，vue-router路由，vuex做状态管理；Vue UI，界面我们一般使用ElementUI（饿了么出品），或者ICE（阿里巴巴出品）来快速搭建前端项目~~</p>
<p>官网：</p>
<ul>
<li>https://element.eleme.cn/#/zh-CN</li>
<li>https://ice.work/</li>
</ul>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#1vue-%E6%A6%82%E8%BF%B0">1.vue 概述</a>
<ul>
<li><a href="#11-%E4%BB%80%E4%B9%88%E6%98%AFmvvm">1.1、什么是MVVM</a></li>
<li><a href="#12-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8mvvm">1.2、为什么要使用MVVM</a></li>
<li><a href="#13-%E4%BB%80%E4%B9%88%E6%98%AFvue">1.3、什么是Vue</a></li>
<li><a href="#14-%E7%AC%AC%E4%B8%80%E4%B8%AAvue%E7%A8%8B%E5%BA%8F">1.4、第一个Vue程序</a></li>
</ul>
</li>
<li><a href="#2%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E6%8C%87%E4%BB%A4">2.基础语法指令</a>
<ul>
<li><a href="#21-v-bind">2.1、v-bind</a></li>
<li><a href="#22-v-if-v-else">2.2、v-if v-else</a></li>
<li><a href="#23-v-for">2.3、v-for</a></li>
<li><a href="#24-v-on">2.4、v-on</a></li>
</ul>
</li>
<li><a href="#3%E8%A1%A8%E5%8D%95%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A">3.表单双向数据绑定</a>
<ul>
<li><a href="#31-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A">3.1、什么是双向数据绑定</a></li>
<li><a href="#32-%E5%9C%A8%E8%A1%A8%E5%8D%95%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A">3.2、在表单中使用双向数据绑定</a></li>
</ul>
</li>
<li><a href="#4%E7%BB%84%E4%BB%B6">4.组件</a>
<ul>
<li><a href="#41-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%84%E4%BB%B6">4.1、什么是组件</a></li>
<li><a href="#42-%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%BB%84%E4%BB%B6">4.2、第一个组件</a></li>
<li><a href="#43-%E4%BD%BF%E7%94%A8props%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0">4.3、使用props传递参数</a></li>
</ul>
</li>
<li><a href="#5axios%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1">5.Axios异步通信</a>
<ul>
<li><a href="#51-%E4%BB%80%E4%B9%88%E6%98%AFaxios">5.1、什么是Axios</a></li>
<li><a href="#52-%E7%AC%AC%E4%B8%80%E4%B8%AAaxios%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F">5.2、第一个Axios应用程序</a></li>
<li><a href="#53-vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">5.3、Vue的生命周期</a></li>
</ul>
</li>
<li><a href="#6%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7-%E5%86%85%E5%AE%B9%E5%88%86%E5%8F%91-%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6">6.计算属性、内容分发、自定义事件</a>
<ul>
<li><a href="#61-%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7">6.1、什么是计算属性</a></li>
<li><a href="#62-%E5%86%85%E5%AE%B9%E5%88%86%E5%8F%91">6.2、内容分发</a></li>
<li><a href="#63-%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6">6.3、自定义事件</a></li>
<li><a href="#64-vue%E5%85%A5%E9%97%A8%E5%B0%8F%E7%BB%93">6.4、vue入门小结</a></li>
<li><a href="#%E8%AF%B4%E6%98%8E">说明</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="http://www.jianso.tech/lab/post/CSS3/">
              <h3 class="post-title">
                CSS3
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">&nbspGridea&nbsp  </a>  On GitHub Pages
  <a class="rss" href="http://www.jianso.tech/lab/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
